# 216. 组合总和 III

## 1. 递归传参的逻辑

​		在回溯不重复问题中，递归传参需要传递当前位置的下一个位置，作为下一层递归 for 循环的起始位置。

​		注意这个传参，传递的应该是当前位置的下一个位置。也就是说，在 for 循环中：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
	k -= 1
	rest -= num
	curr_result.append(num)
	# 这里：需要向下一层传递的应该是当前的 num 的下一个元素
	# 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
	self.getCombines(k, rest, num + 1, curr_result[:])
	k += 1
	rest += num
	curr_result.pop(-1)
```

在 for 循环即将进入下一层递归时，当前的位置应该是 `num`，而不是  `start_index`。这里写错的话，会导致从 2 开始往后的元素都会被多次重复。

## 2. 终止条件

​		本题的终止条件适合用 `k` （剩余可选的元素数量）做判断，因为 `k` 在递归中只有两种情况：`> 0` 或 `== 0`。（因为 `k` 每次只减1，不会像 `rest` 那样突变。）

​		如果用 `rest`（剩余待拼凑的总和）做判断，需要同时对 `> 0`，`< 0` 和 `== 0` 三种情况做判断，会多写很多代码。

```python
# 这里：用 k 来做终止条件
# 用 rest 的话需要三重判断
if k == 0:
	if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
	return
```

## 3. 剪枝优化

​		本题可以做的剪枝有两种：当前元素集合中剩余可选元素的数量要大于等于题目要求的还需要加入组合的元素数量；当前剩余需要拼凑的总和要小于等于准备加入当前组合的元素值，也即：
$$
num <= rest
$$

$$
10 - num <= k
$$

还有一个默认的条件是：
$$
num <= 9
$$
所以在 `for` 循环上写剪枝条件：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):
```

## 4. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []

    def getCombines(self, k, rest, start_index, curr_result):
        # 这里：用 k 来做终止条件
        # 用 rest 的话需要三重判断
        if k == 0:
            if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
                self.result_list.append(curr_result)
            return
        for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
            k -= 1
            rest -= num
            curr_result.append(num)
            # 这里：需要向下一层传递的应该是当前的 num 的下一个元素
            # 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
            self.getCombines(k, rest, num + 1, curr_result[:])
            k += 1
            rest += num
            curr_result.pop(-1)

    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        self.getCombines(k, n, 1, [])
        return self.result_list
```

# 40. 组合总和 II

​		给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
​		candidates 中的每个数字在每个组合中只能使用一次。
​		注意：解集不能包含重复的组合。 

```python
示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

示例 2:
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

​		和组合总和 III 的区别：本题对组合中元素的个数没有限制，并且候选集合中的元素存在重复。

​		和组合总和的区别：本题候选集合中的元素存在重复。

## 1. 同层剪枝

​		因为候选集合中的元素存在重复，想要最终集合中的组合不重复，需要在同一树层上进行剪枝：

![image-20231028100627447](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231028100627447.png)

​		因为是在同一树层上剪枝，所以这个剪枝的过程一定发生在 `for` 循环中，并且不能影响到不同树层间重复元素的选取（例如 `[1, 1, 6]`）。

​		最简单的做法：

```python
for index in range(start_index, len(candidates)):
    ...
    if index > start_index and candidates[index] == candidates[index - 1]:
        continue
    ...
```

`candidates[index] == candidates[index - 1]` 是在把重复的数字构成的树枝剪掉；`index > start_index` 是为了确保这个剪枝过程发生在同一树层上，而不是树层之间。

​		注意：想要实现上述代码的效果，必须先对候选集合 `candidates` 进行排序。

## 2. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []

    def getCombine(self, candidates, start_index, rest):
        if rest == 0:
            self.result_list.append(self.curr_result[:])
            return

        for index in range(start_index, len(candidates)):
            # 因为排序了，所以后面的元素一定更大，不需要再遍历了
            if rest - candidates[index] < 0:
                break
            # 同层剪枝
            if index > start_index and candidates[index] == candidates[index - 1]:
                continue
            rest -= candidates[index]
            self.curr_result.append(candidates[index])
            self.getCombine(candidates, index + 1, rest)
            rest += candidates[index]
            self.curr_result.pop(-1)

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # 必须要先排序！
        candidates.sort()
        self.getCombine(candidates, start_index=0, rest=target)
        return self.result_list
```

# 131. 分割回文串

## 1. 判断是否为回文串

​		可以用双指针法判断一个字符串是否为回文串：

```python
def is_palindrome(self, s):
    """
    判断 s 是否为回文串
    :param s: string 待判断的字符串
    :return: bool 是否为回文串
    """
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

## 2. 如何把分割问题转化为回溯问题

​		对于子串分割问题，现在 `for` 循环遍历的应该是切割位置。对于长为 `length` 的字符串，一共有 `length + 1` 个切割位置（最后一个切割位置在子串的最后，是为了判断终止条件添加的）。

​		因为不能有重复的切割，所以已经切割过一次的位置就不能再进行切割了，每次应该从下一个切割位置开始切割。这也就导致了把当前子串一分为二之后，左边的那个子串是不需要递归切割的（因为它要么是一个单元素子串，要么包含已经被切割过的位置），只需要对右面的那个子串进行递归切割即可。

## 3. 如何判断终止条件

​		结合 2，终止条件应该是当前整个字符串都切割完成之后，所以在长为 `length` 的字符串的 `length` 索引处添加一个切割位置，这个切割位置会把子串切割为一个子串和一个空串。当递归中出现空串时，说明此时切割已经到了末尾，可以向结果集合中添加本次切割的结果了。

## 4. 剪枝

​		结合 2，本次切割之后，左面的那个子串不需要递归切割，因此它是否满足回文串，决定了本次切割是否还需要进行下去。如果它是回文串，那么递归切割右子串；否则，本次切割失败，直接返回。

​		综合上述 2，3，4，可以写出回溯的代码：

```javascript
def get_partition(self, s):
	// 终止条件：切割到字符串的最后
	if not s:
		self.result_list.append(self.curr_list[:])
		return
	// 让切割位置从 1 到 length，length 位置是为了终止条件添加上去的
	for i in range(1, len(s) + 1):
		s_left, s_right = s[:i], s[i:]
		// 左子串是不需要递归切割的，它是否是回文串决定了本次切割是否还需要进行下去
		if not self.is_palindrome(s_left):
			continue
		self.curr_list.append(s_left[:])
		// 递归切割右子串
		self.get_partition(s_right[:])
		// 回溯
		self.curr_list.pop(-1)
```

# 491. 递增子序列

​		给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

​		数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

## 1. 层去重上的陷阱

​		这个题目看起来和之前做的层去重（组合总和 II）很像，但是不能采用之前的方法。因为原始数组不能被排序，否则会破坏题目的要求。也就是说，会出现这样的输入：`nums = [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]`，还有一些重复的 `1` 和前面的 `1` 是分开的。

​		所以这个题目只能采用复杂一点的字典记录法：用一个字典记录该元素在该层上是否已经搜索过了。

```python
def find_subsequences(self, nums, start_index):
	if len(self.curr_result) >= 2:
		self.result_list.append(self.curr_result[:])
	# 这个 used_dict 不作为参数传递，也不能放在全局的 init 里面
	# 因为它只管层去重，而不是整棵树去重。
	used_dict = {}
	for index in range(start_index, min(len(self.curr_result) + len(nums) - 1, len(nums))):
		used_dict.setdefault(nums[index], False)
        # 层去重的部分在这里
		if used_dict[nums[index]]:
			continue
		used_dict[nums[index]] = True
        # 递增剪枝的部分在这里
		if self.curr_result and nums[index] < self.curr_result[-1]:
			continue
		self.curr_result.append(nums[index])
		self.find_subsequences(nums, index + 1)
		self.curr_result.pop(-1)
```

# 100116. 找到冠军 II

​		一场比赛中共有 `n` 支队伍，按从 `0` 到 `n - 1` 编号。每支队伍也是 **有向无环图（DAG）** 上的一个节点。

​		给你一个整数 `n` 和一个下标从 **0** 开始、长度为 `m` 的二维整数数组 `edges` 表示这个有向无环图，其中 `edges[i] = [ui, vi]` 表示图中存在一条从 `ui` 队到 `vi` 队的有向边。

​		从 `a` 队到 `b` 队的有向边意味着 `a` 队比 `b` 队 **强** ，也就是 `b` 队比 `a` 队 **弱** 。

​		在这场比赛中，如果不存在某支强于 `a` 队的队伍，则认为 `a` 队将会是 **冠军** 。

​		如果这场比赛存在 **唯一** 一个冠军，则返回将会成为冠军的队伍。否则，返回 `-1` *。*

**注意**

- **环** 是形如 `a1, a2, ..., an, an+1` 的一个序列，且满足：节点 `a1` 与节点 `an+1` 是同一个节点；节点 `a1, a2, ..., an` 互不相同；对于范围 `[1, n]` 中的每个 `i` ，均存在一条从节点 `ai` 到节点 `ai+1` 的有向边。
- **有向无环图** 是不存在任何环的有向图。

## 1. 最初的思路

​		和《找到冠军 I》不同，`a` 队比 `b` 队强，`b` 队比 `c` 队强，因此 `a` 队比 `c` 队强的这种递推关系，不一定有边，而是有可能通过边之间的传递来表达，所以不能沿用上一题的做法，直接去找有没有一个节点有 `n - 1` 条出边。

​		然后又想到能不能找到每个节点所有路径上的所有节点，衍生出一个回溯+递归的思路，但是这种做法还有一个需要去重的问题。例如 `edges =[[0,1],[1,2],[0,2]], n=3`，在找 `0` 队的路径时，`2` 会被统计两次。在递归和回溯上很难去重，因此这种方法也不能通过。

## 2. 解决方案

​		其实很简单，冠军 = 不能被打败的队伍。统计 `edge[i][1]` 中出现过的所有队伍编号，这些队伍都是被打败过的，不可能是冠军。如果最后仅有一支队伍不在编号集合中，那么这支队伍就是冠军；否则冠军一定不止一个。

​		可以用几行代码快速解决问题：

```python
is_defeated = [False] * n
for edge in edges:
	if not is_defeated[edge[1]]:
		is_defeated[edge[1]] = True
	if sum(is_defeated) == n - 1:
		for group_id in range(n):
			if not is_defeated[group_id]:
	else:
		return -1
```

# 46. 全排列

​		给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

## 1. 和组合问题的区别

​		排列问题和组合问题的区别在于，排列问题是有序的。也就是说，`start_index` 没有意义了，每次都要从头开始遍历。

![image-20231106095622195](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231106095622195.png)

上图中蓝色框的位置，选了 3 之后，还可以调头回来再选 2。

## 2. 最初的想法

​		在递归函数上传递一个 `nums` 的子集，选中一个元素就把这个元素从集合中拿出去，再向下递归；回溯的时候，再把这个元素加回来。

​		可以实现，也能够通过，但是在把元素加回来的时候，需要添加到这个元素原来的位置（否则会重复选取），用到 `python` 的 `insert` 方法，很麻烦。

## 3. 解决方案

​		维护一个 `used` 字典，记录哪些数字已经被选取过了，再 `for` 遍历的时候，把这些数字跳过，不再选取。

​		注意：和 <u>491.递归子序列</u> 的区别。这次的 `used` 字典必须是全局的，因为这次不是在每层上去重，而是在全局路径上去重。也即，对于每条递归路径，不能选取重复的元素。

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []
        # used_dict 必须是一个全局的，因为去重在每条路径上，而不是每层
        self.used_dict = {}

    def get_permute(self, nums):
        if len(self.curr_result) == len(nums):
            self.result_list.append(self.curr_result[:])
            return
        for index in range(0, len(nums)):
            if not self.used_dict[nums[index]]:
                self.curr_result.append(nums[index])
                self.used_dict[nums[index]] = True
                self.get_permute(nums[:])
                self.used_dict[nums[index]] = False
                self.curr_result.pop(-1)

    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        self.used_dict = {num: False for num in nums}
        self.get_permute(nums)
        return self.result_list
```

# 47. 全排列 II

​		给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

## 1. 存在的问题

​		因为 `nums` 包含重复的数字，所以需要在树层上去重。关键问题在于如何判断树层上已经选取过该数字了，同时又不会影响到树枝上的重复选取。

​		因为这里不像是组合问题一样，可以有 `start_index` 标注树层开始的位置，直接用 `if index > 0 and nums[index] == nums[index - 1]` 会把树枝上重复的情况也排除掉，例如 `[1, 1, 2, 2]` 的排列问题。

​		第一次做的时候，我是直接又定义了一个数组 `layer_used`，当选取了一个数字之后，在这个数字之后所有相同的数字，`layer_used` 都设置为 `False`，同层不再重复选取。但是这样需要在 `for` 循环中嵌套小的 `for` 循环，其实并不是很简单……

## 2. 解决方案

​		有 `for` 循环，其实同层数组中的元素一定是按顺序选取的，可以利用这一点。

​		如果 `nums[index] == nums[index - 1]`，同时在全局去重数组 `used[index - 1] == False`，就说明当前 `nums[index]` 已经重复了，可以直接跳过。换言之，我当前选择的数值，和前一个数值相等，但是前一个数值在全局显示没有选取过，说明以它为根的子树已经遍历过了，那么以当前数值为根的子树一定和这个遍历过的子树存在重复，可以直接跳过。如果前一个数值在全局显示选取过了，说明现在正在进行的是树枝上的查找，那么还可以继续遍历当前数值为根的子树。

![image-20231107104738517](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231107104738517.png)

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_list = []
        self.used = []

    def get_permute(self, nums):
        if len(self.curr_list) == len(nums):
            self.result_list.append(self.curr_list[:])
            return
        for index in range(0, len(nums)):
            # 在什么情况下，才能在上一个还没被选择的时候，选择了当前的 index 呢，只能说明上一个已经被遍历过了
            if index > 0 and nums[index] == nums[index - 1] and not self.used[index - 1]:
                continue
            if not self.used[index]:
                self.used[index] = True
                self.curr_list.append(nums[index])
                self.get_permute(nums[:])
                self.curr_list.pop(-1)
                self.used[index] = False

    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        sorted_nums = sorted(nums)
        self.used = [False] * len(nums)
        self.get_permute(sorted_nums[:])
        return self.result_list
```

## 3. 和组合问题树层去重的区别

​		为什么组合问题树层去重不需要这么麻烦？

​		因为在组合问题中有 `start_index`，标志着当前树层遍历的开始，可以很清楚地知道，遍历到当前 `nums[index]` 的时候，前面的 `nums[start_index:index]` 的数值已经被遍历过了。

​		但是对于排列问题，每次 `for` 的遍历都是从 0 开始的，遍历到当前 `nums[index]` 的时候，我没法知道前面的 `nums[:index]` 到底有哪些在当前树层遍历过，需要借助 `used` 数组才行。

# 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

## 1. 贪心算法

### ① 整体逻辑

​		为了找到哪些数字能在最后的摆动序列中保留，需要统计 `nums` 中山谷和山峰的数量：

![image-20231109101947949](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231109101947949.png)

尽可能保留山峰和山谷的数字，把在坡上的数字删除，就能得到最长的摆动序列。

​		综上所述，可以得到统计的基本条件：`pre_diff > 0 and curr_diff < 0 or pre_diff < 0 and curr_diff > 0`。

### ②  对山峰山谷情况的讨论

​		上述条件需要补充一些特殊情况，以山峰为例，山谷也是一样的。

​		第一种情况是平顶山峰：

![image-20231109102309886](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231109102309886.png)

按照原始统计条件，会得到结果 2，但是实际上在平顶山峰上也要统计一次，正确结果应该是 3。如果删除前三个元素，则修改条件为 `pre_diff >= 0 and curr_diff < 0 or pre_diff <= 0 and curr_diff > 0`。换言之，给其中一边加上等号即可。

​		第二种情况是连续上坡：

![image-20231109102516313](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231109102516313.png)

按照上述统计条件，会得到答案 3，实际上在 2 → 3 的位置根本不应该再统计一次（因为是连续上坡，其实没有山峰）。其实 `pre_diff` 和 `curr_diff` 的值本身不重要，重要的是它们的符号。因此，只有当波动变化时才更新 `pre_diff` 的值。

### ③ 对数组两端的考虑

​		上述条件中没有考虑数组两端元素的情况。按照 ① 中修改的条件，对于数组的左端点，可以想象其前面还有一个伪数字和其值相等，此时 `pre_diff == 0 and curr_diff > 0 (或 < 0)`，正好会被记入一次。对于数组的右端点，可以默认其有一个山峰或山谷，所以让 `result` 从 1 开始。

### ④ 代码实现

```python
class Solution(object):
    def __init__(self):
        # self.pre_diff 从 0 开始，遍历也从 index = 0 开始，相当于数组的左端点
        self.pre_diff = 0
        self.curr_diff = 0
        # result 从 1 开始，相当于数组的右端点
        self.result = 1

    def wiggleMaxLength(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        for index in range(len(nums) - 1):
            self.curr_diff = nums[index + 1] - nums[index]
            # 出现谷底或山峰
            # 注意：平顶山峰或平底山谷也要算 1 个
            if (self.pre_diff <= 0 and self.curr_diff > 0) or (self.pre_diff >= 0 and self.curr_diff < 0):
                self.result += 1
                # self.pre_diff 和 self.curr_diff 的数值不重要，重要的是正负
                # 只有出现波动的时候才更新 self.pre_diff，这样能避开连续上坡或连续下坡的情况
                self.pre_diff = self.curr_diff
        return self.result
```

# 53. 最大子数组和

## 1. 贪心算法

​		这个题目的贪心算法特别不好想。

​		用一个 `count` 记录子数组的和，如果到某个数字时 `count < 0`，说明这个数字对于得到最大子数组和没有益处，甚至有害处（之后再加上的数字都相当于在一个负数的基础上加，都变小了），为了得到最大子数组和，需要将这个数字丢弃，即从下一个数字开始重新计算子数组的和 `count`。

​		每遍历一个数字都需要判断当前 `count` 是不是最大子数组和。

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_sum = nums[0]
        count = 0
        for i in range(len(nums)):
            count += nums[i]
            max_sum = max(max_sum, count)
            if count < 0:
                count = 0
        return max_sum
```

# 100117.最大化数组末位元素的最少操作次数

​		给你两个下标从 **0** 开始的整数数组 `nums1` 和 `nums2` ，这两个数组的长度都是 `n` 。

​		你可以执行一系列 **操作（可能不执行）**。

​		在每次操作中，你可以选择一个在范围 `[0, n - 1]` 内的下标 `i` ，并交换 `nums1[i]` 和 `nums2[i]` 的值。

​		你的任务是找到满足以下条件所需的 **最小** 操作次数：

- `nums1[n - 1]` 等于 `nums1` 中所有元素的 **最大值** ，即 `nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1])` 。
- `nums2[n - 1]` 等于 `nums2` 中所有元素的 **最大值** ，即 `nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1])` 。

​		以整数形式，表示并返回满足上述 **全部** 条件所需的 **最小** 操作次数，如果无法同时满足两个条件，则返回 `-1` 。

## 1. 最初的想法

​		第一次做的时候，想法是如果不满足条件，先换最后一个元素，然后对不满足条件的数组，从最大值开始换起，直到满足条件为止。

​		其实整体思路已经对了：如果某个数字比末位元素要大，它必须和另一个数组中的同位元素交换，否则无法满足条件。但是前提条件有问题：一开始末位元素不一定要发生交换。例如：

```python
nums1 = [1, 1, 8, 9]
nums2 = [1, 7, 1, 1]
```

只要交换 `i = 1` 位置的元素就能满足条件，最少操作次数应该为 1。此时，原本的末位元素并没有发生交换。

## 2. 解决方案

​		综上所述，因为只需要最大化末位元素，所以对末位元素分情况讨论：

- 末位元素交换。此时初始的 `count = 1`
- 末位元素不交换。此时初始的 `count = 0`

​		随后，遍历两个数组，如果有不满足条件的元素，就让两个数组的对应位置交换。如果交换后还是不能满足条件，那说明这种方案是行不通的，返回 `-1`。

​		最后，从两种方案里选择成功的那一个，如果两种方案都能成功，就选择更小的那一个。

```python
class Solution(object):
    def count_swaps(self, nums1, nums2, is_swap):
        # 求交换次数
        count = 0
        if is_swap:  # 其实不需要真正的交换两个数组中的元素，计数即可
            last1, last2 = nums2[-1], nums1[-1]
            count += 1
        else:
            last1, last2 = nums1[-1], nums2[-1]
        for index in range(len(nums1) - 1):
            # 如果有一个数组不满足条件，就必须触发交换
            if nums1[index] > last1 or nums2[index] > last2:
                # 如果交换之后还是不满足条件，说明当前方案不成立
                if nums1[index] > last2 or nums2[index] > last1:
                    return -1
                count += 1
        return count

    def minOperations(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        # 末位元素交换
        ans1 = self.count_swaps(nums1=nums1[:], nums2=nums2[:], is_swap=True)
        # 末位元素不交换
        ans2 = self.count_swaps(nums1=nums1[:], nums2=nums2[:], is_swap=False)
        if ans1 < 0:
            if ans2 < 0:
                return -1
            else:
                return ans2
        else:
            if ans2 < 0:
                return ans1
            else:
                return min(ans1, ans2)
```

# 55. 跳跃游戏  & 45. 跳跃游戏 II

​		给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

​		判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

----

​		给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

​		每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

​		返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

## 1. 题目存在的问题

​		数组的下标是我们要到达的位置，对应的值是在该位置能够跳跃的最远距离。这点题干说得非常不清楚，最后需要到达的位置应该是 `len(nums) - 1`，和最后一个元素没有什么关系。

## 2.贪心算法

​		无论是找能否跳到还是跳跃的最少步数，都可以用覆盖范围的方法来求解。

​		对于能否跳到，只要覆盖范围能到达最后一个下标，就能跳到。

​		对于最少跳跃次数，在覆盖范围内尽可能跳得远一点，少增加几次跳跃，就能找到最少跳跃次数。需要记录两个数据：当前的最远覆盖范围 `curr_cover` 和下一个最远覆盖范围 `next_cover` 。遍历下标位置 `index`，更新下一个最远覆盖范围 `next_cover`，当 `index` 到达 `curr_cover` 时，说明当前这一步已经走到了尽头，如果此时还没能到达终点，就只能再跳一步，同时启用 `next_cover`。每次跳跃之后都需要判断 `curr_cover` 是否覆盖了终点，如果已经覆盖了终点，就不需要继续遍历了。

```python
class Solution(object):
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return 0
        steps = 0
        curr_cover = 0
        next_cover = 0
        for index in range(len(nums)):
            # 更新下一次能够跳跃到的最远距离
            next_cover = max(next_cover, index + nums[index])
            # 本次跳跃的范围到了尽头，只能再跳一次
            if index == curr_cover:
                steps += 1
                curr_cover = next_cover
                # 如果已经覆盖了终点，可以结束遍历
                if next_cover >= len(nums) - 1:
                    break
        return steps
```

# 1005. K次取反后最大化的数组和

​		给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

​		重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

​		以这种方式修改数组后，返回数组 **可能的最大和** 。

## 1. 问题

​		整体思路就是每次把最小的负数转换成正数，当没有负数，但是 `K` 值还有时，来回转换最小的数字，直到把次数耗光。

​		第一次做的时候，把数组从小到大排序，从最小的数字开始转换，但是这样存在一个问题：负数转换成正数之后，数组就不再有序了，所以每次都需要重新排序数组，造成时间复杂度很高。

## 2. 解决方案

​		把数组按照绝对值大小从大到小排序，第一遍从左到右遍历数组，把所有的负数变成正数，同时 `K` 减小。遍历完成之后，如果 `K` 还有次数，就把最右边的数字来回切换，直到次数耗完。

​		第一遍从左到右把负数变成正数之后，因为数组是按照绝对值排序的，转换完成之后数组还是有序的，并且最右边的数字是最小的。如果还有剩下的次数，正好把这个最小的数字来回切换。

```python
class Solution(object):
    def largestSumAfterKNegations(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        nums.sort(key=lambda x: abs(x), reverse=True)
        for index in range(len(nums)):
            if nums[index] < 0:
                nums[index] *= -1
                k -= 1
                if k == 0:
                    break
        while k > 0:
            nums[-1] *= -1
            k -= 1
        return sum(nums)
```

# 134. 加油站

## 1. 贪心思路

​		首先，在环路过程中，能获得的总油量和消耗的总油量是固定的（就是 `gas` 和 `cost` 的和），所以不能绕环的条件一开始就能判断（这点我也想到啦^^)。

​		接下来考虑要从哪个下标位置开始。用 `rest` 表示剩余油量，在每个加油站处，`rest[index] = gas[index] - cost[index]`。为了能够绕环，在整个遍历过程中，应该要求 `rest` 始终不能为负数，否则没法绕环。

​		这里，用和最大子数组和相似的贪心思路！累加 `rest` 的值，如果在某个 `index` 位置，累加和为负数，说明在 `[0, index]` 的区间内都不能作为起始位置，新的起始位置从 `index + 1` 开始算起。

​		完整代码：

```python
class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """
        if sum(gas) < sum(cost):
            return -1
        start_index, curr_sum = 0, 0
        for index in range(len(gas)):
            curr_sum += (gas[index] - cost[index])
            if curr_sum < 0:
                start_index = index + 1
                curr_sum = 0
        return start_index
```

注意：虽然只遍历了一遍，但是能保证找到的 `index` 位置一定是结果。因为从这个位置开始如果又发现了负数，从环的角度看，新的起始位置就又绕回了刚刚遍历过的位置，但是刚刚遍历过的位置已经没有结果了，那只能说明结果不存在，和整体的条件出现了矛盾。

---

# 452.用最少数量的箭引爆气球

​		有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

​		一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

​		给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

## 1.思路

​		贪心。

​		尽可能把箭射到气球的重叠位置上，就能一次引爆尽可能多的气球。从整体上来看，最后需要的箭的数量就会更少。

​		我发现我的具体求解思路和代码随想录的有点不一样，不知道将来会不会出现问题，先记录一下。

​		我的想法是，先把气球排序，为了引爆当前`index`位置的气球，在最远位置的箭就是`end`位置的箭，然后继续遍历，让这个位置的箭先引爆气球，如果遍历到某个气球不能被这支箭引爆，就射出一支新的箭，箭的位置是这个`index`的`end`位置。

​		出现的问题是，采用`start`还是`end`来排序呢？

​		我第一遍做的时候，是用`start`来排序的，但是这样会没法 AC：如果出现`[7, 12], [9, 10]`的样例，遍历到`[7, 12]`的时候会把下一支箭的位置更新为 12，再遍历到`[9, 10]`的时候就得射出一支新的箭了，但是实际上在 10 的位置射出一支箭可以直接引爆两个气球，因为这两个气球是互相嵌套的。

​		所以，我换成用`end`来排序，思路和上述贪心的思路相同，最后就能 AC 了。

## 2.代码随想录的解决方案

​		代码随想录上的解题方案按照`start`来排序，同时去找前后两个气球的重叠位置，以重叠位置较小的那个`end`作为箭射出的位置。（这么一想，或许和我的思路也差不多？）

---

# 435.无重叠区间

​		给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

## 1.最初的思路

​		最初我想把区间按照`start`从前到后排序，当两个区间重叠时，就删除较长的那一个。

​		这种贪心的思路是错误的：对于区间`[58, 95], [66, 98], [82, 97], [95, 99]`，按照上述逻辑会删除 3 个区间（因为上来就会把`[58, 95]`给删除，剩下 3 个区间全都相互重叠），但是实际上只删除 2 个区间即可（`[66, 98], [82, 97]`）。

## 2.正确的思路

​		删除的区间 = 全部区间 - 互不重叠的区间。

​		换言之，想要被删除的区间尽可能少，互不重叠的区间需要尽可能多。因此，应该按照`end`从前到后排序。

​		当遇到互不重叠的区间时，计数加 1，同时更新当前区间的`end`位置。

```python
class Solution(object):
    def eraseOverlapIntervals(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: int
        """
        intervals.sort(key=lambda interval: (interval[1], interval[0]))
        count = 1
        pre_end = intervals[0][1]
        for index in range(1, len(intervals)):
            # 遇到互不重叠的区间
            if intervals[index][0] >= pre_end:
                count += 1
                pre_end = intervals[index][1]
        return len(intervals) - count
```

---

# 763.划分字母区间

​		给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

​		注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

​		返回一个表示每个字符串片段的长度的列表。

## 1.我的思路

​		和重叠区间的思路差不多：先统计每个字母出现的起始和终点位置，然后找到所有的无重叠包裹区间。

```python
class Solution(object):
    def partitionLabels(self, s):
        """
        :type s: str
        :rtype: List[int]
        """
        result_list = []
        # 统计每个字母的起止位置
        char_dict = {}
        for index in range(len(s)):
            char = s[index]
            char_dict.setdefault(char, [index, index])
            char_dict[char][1] = index
        index_list = list(char_dict.values())
        index_list.sort(key=lambda item: item[0])
        start, end = index_list[0][0], index_list[0][1]
        for i in range(1, len(index_list)):
            if index_list[i][0] > end:
                # 出现了新的区间
                result_list.append(end - start + 1)
                start, end = index_list[i][0], index_list[i][1]
            else:
                # 统计最远位置
                # 因为要把之前出现过的所有字母都包裹其中
                end = max(end, index_list[i][1])
        result_list.append(end - start + 1)
        return result_list
```

## 2.代码随想录的解决方案

​		只需要统计字母出现的最终位置，然后遍历字符串，每遍历一个字母，计算当前字符串的最远位置。当遍历到下标和最远位置相等的位置时，说明从这里分割，前面出现的所有字母都能被包裹其中（因为已经到达最远位置了！）。

![image-20231122102227646](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231122102227646.png)

```python
class Solution(object):
    def partitionLabels(self, s):
        """
        :type s: str
        :rtype: List[int]
        """
        result_list = []
        char_dict = {}
        # 统计当前字母出现的最后位置
        for index in range(len(s)):
            char = s[index]
            char_dict.setdefault(char, index)
            char_dict[char] = index
        start, end = 0, 0
        for index in range(len(s)):
            char = s[index]
            end = max(end, char_dict[char])
            # 如果当前下标位置和之前出现字母的最远位置相等
            # 说明在当前下标位置分割，可以把之前所有出现的字母划分到一个片段中
            if index == end:
                result_list.append(end - start + 1)
                start, end = end + 1, end + 1
        return result_list
```

这样能加快运行速度，同时降低内存消耗。

---

# 738.单调递增的数字

​		当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

​		给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

## 1.第一次提交出现的问题

​		一开始就想到，从低位开始往高位遍历，一旦遇到`n[i] < n[i - 1]`的情况，为了让数字尽可能大，并且比原始数字要小，需要把`n[i]`设置为 9，`n[i - 1]`减 1。

​		在样例`n = 100`时，正确答案为 99，上述方法得到的答案为 90。

​		出错的原因在于，当遍历 0 和 0 的时候，不会发生变化，但是遍历到 0 和 1 的时候，0 变成 9，1 变成 0，这个时候，0 和 9 又不满足关系了。

​		所以当把`n[i]`设置为 9 的时候，后面的低位也需要全部设置为 9， 这样才能保证满足递增数字关系。

## 2.代码

```python
class Solution(object):
    def monotoneIncreasingDigits(self, n):
        """
        :type n: int
        :rtype: int
        """
        n_bit = []
        rest = n
        while rest > 0:
            n_bit.append(rest % 10)
            rest = int(rest / 10)
        for index in range(len(n_bit) - 1):
            if n_bit[index] < n_bit[index + 1]:
                # 在这个位置发生了变化
                n_bit[index] = 9
                # 需要将之前遍历过的位数都变成9，以保证递增序列
                j = index - 1
                while j >= 0:
                    n_bit[j] = 9
                    j -= 1
                n_bit[index + 1] -= 1
        new_n = 0
        for index in range(len(n_bit) - 1, -1, -1):
            new_n *= 10
            new_n += n_bit[index]
        return new_n
```
