# 216. 组合总和 III

## 1. 递归传参的逻辑

​		在回溯不重复问题中，递归传参需要传递当前位置的下一个位置，作为下一层递归 for 循环的起始位置。

​		注意这个传参，传递的应该是当前位置的下一个位置。也就是说，在 for 循环中：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
	k -= 1
	rest -= num
	curr_result.append(num)
	# 这里：需要向下一层传递的应该是当前的 num 的下一个元素
	# 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
	self.getCombines(k, rest, num + 1, curr_result[:])
	k += 1
	rest += num
	curr_result.pop(-1)
```

在 for 循环即将进入下一层递归时，当前的位置应该是 `num`，而不是  `start_index`。这里写错的话，会导致从 2 开始往后的元素都会被多次重复。

## 2. 终止条件

​		本题的终止条件适合用 `k` （剩余可选的元素数量）做判断，因为 `k` 在递归中只有两种情况：`> 0` 或 `== 0`。（因为 `k` 每次只减1，不会像 `rest` 那样突变。）

​		如果用 `rest`（剩余待拼凑的总和）做判断，需要同时对 `> 0`，`< 0` 和 `== 0` 三种情况做判断，会多写很多代码。

```python
# 这里：用 k 来做终止条件
# 用 rest 的话需要三重判断
if k == 0:
	if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
	return
```

## 3. 剪枝优化

​		本题可以做的剪枝有两种：当前元素集合中剩余可选元素的数量要大于等于题目要求的还需要加入组合的元素数量；当前剩余需要拼凑的总和要小于等于准备加入当前组合的元素值，也即：
$$
num <= rest
$$

$$
10 - num <= k
$$

还有一个默认的条件是：
$$
num <= 9
$$
所以在 `for` 循环上写剪枝条件：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):
```

## 4. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []

    def getCombines(self, k, rest, start_index, curr_result):
        # 这里：用 k 来做终止条件
        # 用 rest 的话需要三重判断
        if k == 0:
            if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
                self.result_list.append(curr_result)
            return
        for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
            k -= 1
            rest -= num
            curr_result.append(num)
            # 这里：需要向下一层传递的应该是当前的 num 的下一个元素
            # 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
            self.getCombines(k, rest, num + 1, curr_result[:])
            k += 1
            rest += num
            curr_result.pop(-1)

    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        self.getCombines(k, n, 1, [])
        return self.result_list
```

# 40. 组合总和 II

​		给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
​		candidates 中的每个数字在每个组合中只能使用一次。
​		注意：解集不能包含重复的组合。 

```python
示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

示例 2:
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

​		和组合总和 III 的区别：本题对组合中元素的个数没有限制，并且候选集合中的元素存在重复。

​		和组合总和的区别：本题候选集合中的元素存在重复。

## 1. 同层剪枝

​		因为候选集合中的元素存在重复，想要最终集合中的组合不重复，需要在同一树层上进行剪枝：

![image-20231028100627447](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231028100627447.png)

​		因为是在同一树层上剪枝，所以这个剪枝的过程一定发生在 `for` 循环中，并且不能影响到不同树层间重复元素的选取（例如 `[1, 1, 6]`）。

​		最简单的做法：

```python
for index in range(start_index, len(candidates)):
    ...
    if index > start_index and candidates[index] == candidates[index - 1]:
        continue
    ...
```

`candidates[index] == candidates[index - 1]` 是在把重复的数字构成的树枝剪掉；`index > start_index` 是为了确保这个剪枝过程发生在同一树层上，而不是树层之间。

​		注意：想要实现上述代码的效果，必须先对候选集合 `candidates` 进行排序。

## 2. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []

    def getCombine(self, candidates, start_index, rest):
        if rest == 0:
            self.result_list.append(self.curr_result[:])
            return

        for index in range(start_index, len(candidates)):
            # 因为排序了，所以后面的元素一定更大，不需要再遍历了
            if rest - candidates[index] < 0:
                break
            # 同层剪枝
            if index > start_index and candidates[index] == candidates[index - 1]:
                continue
            rest -= candidates[index]
            self.curr_result.append(candidates[index])
            self.getCombine(candidates, index + 1, rest)
            rest += candidates[index]
            self.curr_result.pop(-1)

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # 必须要先排序！
        candidates.sort()
        self.getCombine(candidates, start_index=0, rest=target)
        return self.result_list
```

# 131. 分割回文串

## 1. 判断是否为回文串

​		可以用双指针法判断一个字符串是否为回文串：

```python
def is_palindrome(self, s):
    """
    判断 s 是否为回文串
    :param s: string 待判断的字符串
    :return: bool 是否为回文串
    """
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

## 2. 如何把分割问题转化为回溯问题

​		对于子串分割问题，现在 `for` 循环遍历的应该是切割位置。对于长为 `length` 的字符串，一共有 `length + 1` 个切割位置（最后一个切割位置在子串的最后，是为了判断终止条件添加的）。

​		因为不能有重复的切割，所以已经切割过一次的位置就不能再进行切割了，每次应该从下一个切割位置开始切割。这也就导致了把当前子串一分为二之后，左边的那个子串是不需要递归切割的（因为它要么是一个单元素子串，要么包含已经被切割过的位置），只需要对右面的那个子串进行递归切割即可。

## 3. 如何判断终止条件

​		结合 2，终止条件应该是当前整个字符串都切割完成之后，所以在长为 `length` 的字符串的 `length` 索引处添加一个切割位置，这个切割位置会把子串切割为一个子串和一个空串。当递归中出现空串时，说明此时切割已经到了末尾，可以向结果集合中添加本次切割的结果了。

## 4. 剪枝

​		结合 2，本次切割之后，左面的那个子串不需要递归切割，因此它是否满足回文串，决定了本次切割是否还需要进行下去。如果它是回文串，那么递归切割右子串；否则，本次切割失败，直接返回。

​		综合上述 2，3，4，可以写出回溯的代码：

```javascript
def get_partition(self, s):
	// 终止条件：切割到字符串的最后
	if not s:
		self.result_list.append(self.curr_list[:])
		return
	// 让切割位置从 1 到 length，length 位置是为了终止条件添加上去的
	for i in range(1, len(s) + 1):
		s_left, s_right = s[:i], s[i:]
		// 左子串是不需要递归切割的，它是否是回文串决定了本次切割是否还需要进行下去
		if not self.is_palindrome(s_left):
			continue
		self.curr_list.append(s_left[:])
		// 递归切割右子串
		self.get_partition(s_right[:])
		// 回溯
		self.curr_list.pop(-1)
```

# 491. 递增子序列

​		给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

​		数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

## 1. 层去重上的陷阱

​		这个题目看起来和之前做的层去重（组合总和 II）很像，但是不能采用之前的方法。因为原始数组不能被排序，否则会破坏题目的要求。也就是说，会出现这样的输入：`nums = [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]`，还有一些重复的 `1` 和前面的 `1` 是分开的。

​		所以这个题目只能采用复杂一点的字典记录法：用一个字典记录该元素在该层上是否已经搜索过了。

```python
def find_subsequences(self, nums, start_index):
	if len(self.curr_result) >= 2:
		self.result_list.append(self.curr_result[:])
	# 这个 used_dict 不作为参数传递，也不能放在全局的 init 里面
	# 因为它只管层去重，而不是整棵树去重。
	used_dict = {}
	for index in range(start_index, min(len(self.curr_result) + len(nums) - 1, len(nums))):
		used_dict.setdefault(nums[index], False)
        # 层去重的部分在这里
		if used_dict[nums[index]]:
			continue
		used_dict[nums[index]] = True
        # 递增剪枝的部分在这里
		if self.curr_result and nums[index] < self.curr_result[-1]:
			continue
		self.curr_result.append(nums[index])
		self.find_subsequences(nums, index + 1)
		self.curr_result.pop(-1)
```

# 100116. 找到冠军 II

​		一场比赛中共有 `n` 支队伍，按从 `0` 到 `n - 1` 编号。每支队伍也是 **有向无环图（DAG）** 上的一个节点。

​		给你一个整数 `n` 和一个下标从 **0** 开始、长度为 `m` 的二维整数数组 `edges` 表示这个有向无环图，其中 `edges[i] = [ui, vi]` 表示图中存在一条从 `ui` 队到 `vi` 队的有向边。

​		从 `a` 队到 `b` 队的有向边意味着 `a` 队比 `b` 队 **强** ，也就是 `b` 队比 `a` 队 **弱** 。

​		在这场比赛中，如果不存在某支强于 `a` 队的队伍，则认为 `a` 队将会是 **冠军** 。

​		如果这场比赛存在 **唯一** 一个冠军，则返回将会成为冠军的队伍。否则，返回 `-1` *。*

**注意**

- **环** 是形如 `a1, a2, ..., an, an+1` 的一个序列，且满足：节点 `a1` 与节点 `an+1` 是同一个节点；节点 `a1, a2, ..., an` 互不相同；对于范围 `[1, n]` 中的每个 `i` ，均存在一条从节点 `ai` 到节点 `ai+1` 的有向边。
- **有向无环图** 是不存在任何环的有向图。

## 1. 最初的思路

​		和《找到冠军 I》不同，`a` 队比 `b` 队强，`b` 队比 `c` 队强，因此 `a` 队比 `c` 队强的这种递推关系，不一定有边，而是有可能通过边之间的传递来表达，所以不能沿用上一题的做法，直接去找有没有一个节点有 `n - 1` 条出边。

​		然后又想到能不能找到每个节点所有路径上的所有节点，衍生出一个回溯+递归的思路，但是这种做法还有一个需要去重的问题。例如 `edges =[[0,1],[1,2],[0,2]], n=3`，在找 `0` 队的路径时，`2` 会被统计两次。在递归和回溯上很难去重，因此这种方法也不能通过。

## 2. 解决方案

​		其实很简单，冠军 = 不能被打败的队伍。统计 `edge[i][1]` 中出现过的所有队伍编号，这些队伍都是被打败过的，不可能是冠军。如果最后仅有一支队伍不在编号集合中，那么这支队伍就是冠军；否则冠军一定不止一个。

​		可以用几行代码快速解决问题：

```python
is_defeated = [False] * n
for edge in edges:
	if not is_defeated[edge[1]]:
		is_defeated[edge[1]] = True
	if sum(is_defeated) == n - 1:
		for group_id in range(n):
			if not is_defeated[group_id]:
	else:
		return -1
```

# 46. 全排列

​		给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

## 1. 和组合问题的区别

​		排列问题和组合问题的区别在于，排列问题是有序的。也就是说，`start_index` 没有意义了，每次都要从头开始遍历。

![image-20231106095622195](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231106095622195.png)

上图中蓝色框的位置，选了 3 之后，还可以调头回来再选 2。

## 2. 最初的想法

​		在递归函数上传递一个 `nums` 的子集，选中一个元素就把这个元素从集合中拿出去，再向下递归；回溯的时候，再把这个元素加回来。

​		可以实现，也能够通过，但是在把元素加回来的时候，需要添加到这个元素原来的位置（否则会重复选取），用到 `python` 的 `insert` 方法，很麻烦。

## 3. 解决方案

​		维护一个 `used` 字典，记录哪些数字已经被选取过了，再 `for` 遍历的时候，把这些数字跳过，不再选取。

​		注意：和 <u>491.递归子序列</u> 的区别。这次的 `used` 字典必须是全局的，因为这次不是在每层上去重，而是在全局路径上去重。也即，对于每条递归路径，不能选取重复的元素。

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []
        # used_dict 必须是一个全局的，因为去重在每条路径上，而不是每层
        self.used_dict = {}

    def get_permute(self, nums):
        if len(self.curr_result) == len(nums):
            self.result_list.append(self.curr_result[:])
            return
        for index in range(0, len(nums)):
            if not self.used_dict[nums[index]]:
                self.curr_result.append(nums[index])
                self.used_dict[nums[index]] = True
                self.get_permute(nums[:])
                self.used_dict[nums[index]] = False
                self.curr_result.pop(-1)

    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        self.used_dict = {num: False for num in nums}
        self.get_permute(nums)
        return self.result_list
```

# 47. 全排列 II

​		给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

## 1. 存在的问题

​		因为 `nums` 包含重复的数字，所以需要在树层上去重。关键问题在于如何判断树层上已经选取过该数字了，同时又不会影响到树枝上的重复选取。

​		因为这里不像是组合问题一样，可以有 `start_index` 标注树层开始的位置，直接用 `if index > 0 and nums[index] == nums[index - 1]` 会把树枝上重复的情况也排除掉，例如 `[1, 1, 2, 2]` 的排列问题。

​		第一次做的时候，我是直接又定义了一个数组 `layer_used`，当选取了一个数字之后，在这个数字之后所有相同的数字，`layer_used` 都设置为 `False`，同层不再重复选取。但是这样需要在 `for` 循环中嵌套小的 `for` 循环，其实并不是很简单……

## 2. 解决方案

​		有 `for` 循环，其实同层数组中的元素一定是按顺序选取的，可以利用这一点。

​		如果 `nums[index] == nums[index - 1]`，同时在全局去重数组 `used[index - 1] == False`，就说明当前 `nums[index]` 已经重复了，可以直接跳过。换言之，我当前选择的数值，和前一个数值相等，但是前一个数值在全局显示没有选取过，说明以它为根的子树已经遍历过了，那么以当前数值为根的子树一定和这个遍历过的子树存在重复，可以直接跳过。如果前一个数值在全局显示选取过了，说明现在正在进行的是树枝上的查找，那么还可以继续遍历当前数值为根的子树。

![image-20231107104738517](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231107104738517.png)

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_list = []
        self.used = []

    def get_permute(self, nums):
        if len(self.curr_list) == len(nums):
            self.result_list.append(self.curr_list[:])
            return
        for index in range(0, len(nums)):
            # 在什么情况下，才能在上一个还没被选择的时候，选择了当前的 index 呢，只能说明上一个已经被遍历过了
            if index > 0 and nums[index] == nums[index - 1] and not self.used[index - 1]:
                continue
            if not self.used[index]:
                self.used[index] = True
                self.curr_list.append(nums[index])
                self.get_permute(nums[:])
                self.curr_list.pop(-1)
                self.used[index] = False

    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        sorted_nums = sorted(nums)
        self.used = [False] * len(nums)
        self.get_permute(sorted_nums[:])
        return self.result_list
```

## 3. 和组合问题树层去重的区别

​		为什么组合问题树层去重不需要这么麻烦？

​		因为在组合问题中有 `start_index`，标志着当前树层遍历的开始，可以很清楚地知道，遍历到当前 `nums[index]` 的时候，前面的 `nums[start_index:index]` 的数值已经被遍历过了。

​		但是对于排列问题，每次 `for` 的遍历都是从 0 开始的，遍历到当前 `nums[index]` 的时候，我没法知道前面的 `nums[:index]` 到底有哪些在当前树层遍历过，需要借助 `used` 数组才行。

# 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

## 1. 贪心算法

### ① 整体逻辑

​		为了找到哪些数字能在最后的摆动序列中保留，需要统计 `nums` 中山谷和山峰的数量：

![image-20231109101947949](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231109101947949.png)

尽可能保留山峰和山谷的数字，把在坡上的数字删除，就能得到最长的摆动序列。

​		综上所述，可以得到统计的基本条件：`pre_diff > 0 and curr_diff < 0 or pre_diff < 0 and curr_diff > 0`。

### ②  对山峰山谷情况的讨论

​		上述条件需要补充一些特殊情况，以山峰为例，山谷也是一样的。

​		第一种情况是平顶山峰：

![image-20231109102309886](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231109102309886.png)

按照原始统计条件，会得到结果 2，但是实际上在平顶山峰上也要统计一次，正确结果应该是 3。如果删除前三个元素，则修改条件为 `pre_diff >= 0 and curr_diff < 0 or pre_diff <= 0 and curr_diff > 0`。换言之，给其中一边加上等号即可。

​		第二种情况是连续上坡：

![image-20231109102516313](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231109102516313.png)

按照上述统计条件，会得到答案 3，实际上在 2 → 3 的位置根本不应该再统计一次（因为是连续上坡，其实没有山峰）。其实 `pre_diff` 和 `curr_diff` 的值本身不重要，重要的是它们的符号。因此，只有当波动变化时才更新 `pre_diff` 的值。

### ③ 对数组两端的考虑

​		上述条件中没有考虑数组两端元素的情况。按照 ① 中修改的条件，对于数组的左端点，可以想象其前面还有一个伪数字和其值相等，此时 `pre_diff == 0 and curr_diff > 0 (或 < 0)`，正好会被记入一次。对于数组的右端点，可以默认其有一个山峰或山谷，所以让 `result` 从 1 开始。

### ④ 代码实现

```python
class Solution(object):
    def __init__(self):
        # self.pre_diff 从 0 开始，遍历也从 index = 0 开始，相当于数组的左端点
        self.pre_diff = 0
        self.curr_diff = 0
        # result 从 1 开始，相当于数组的右端点
        self.result = 1

    def wiggleMaxLength(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        for index in range(len(nums) - 1):
            self.curr_diff = nums[index + 1] - nums[index]
            # 出现谷底或山峰
            # 注意：平顶山峰或平底山谷也要算 1 个
            if (self.pre_diff <= 0 and self.curr_diff > 0) or (self.pre_diff >= 0 and self.curr_diff < 0):
                self.result += 1
                # self.pre_diff 和 self.curr_diff 的数值不重要，重要的是正负
                # 只有出现波动的时候才更新 self.pre_diff，这样能避开连续上坡或连续下坡的情况
                self.pre_diff = self.curr_diff
        return self.result
```

# 53. 最大子数组和

## 1. 贪心算法

​		这个题目的贪心算法特别不好想。

​		用一个 `count` 记录子数组的和，如果到某个数字时 `count < 0`，说明这个数字对于得到最大子数组和没有益处，甚至有害处（之后再加上的数字都相当于在一个负数的基础上加，都变小了），为了得到最大子数组和，需要将这个数字丢弃，即从下一个数字开始重新计算子数组的和 `count`。

​		每遍历一个数字都需要判断当前 `count` 是不是最大子数组和。

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_sum = nums[0]
        count = 0
        for i in range(len(nums)):
            count += nums[i]
            max_sum = max(max_sum, count)
            if count < 0:
                count = 0
        return max_sum
```

# 100117.最大化数组末位元素的最少操作次数

​		给你两个下标从 **0** 开始的整数数组 `nums1` 和 `nums2` ，这两个数组的长度都是 `n` 。

​		你可以执行一系列 **操作（可能不执行）**。

​		在每次操作中，你可以选择一个在范围 `[0, n - 1]` 内的下标 `i` ，并交换 `nums1[i]` 和 `nums2[i]` 的值。

​		你的任务是找到满足以下条件所需的 **最小** 操作次数：

- `nums1[n - 1]` 等于 `nums1` 中所有元素的 **最大值** ，即 `nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1])` 。
- `nums2[n - 1]` 等于 `nums2` 中所有元素的 **最大值** ，即 `nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1])` 。

​		以整数形式，表示并返回满足上述 **全部** 条件所需的 **最小** 操作次数，如果无法同时满足两个条件，则返回 `-1` 。

## 1. 最初的想法

​		第一次做的时候，想法是如果不满足条件，先换最后一个元素，然后对不满足条件的数组，从最大值开始换起，直到满足条件为止。

​		其实整体思路已经对了：如果某个数字比末位元素要大，它必须和另一个数组中的同位元素交换，否则无法满足条件。但是前提条件有问题：一开始末位元素不一定要发生交换。例如：

```python
nums1 = [1, 1, 8, 9]
nums2 = [1, 7, 1, 1]
```

只要交换 `i = 1` 位置的元素就能满足条件，最少操作次数应该为 1。此时，原本的末位元素并没有发生交换。

## 2. 解决方案

​		综上所述，因为只需要最大化末位元素，所以对末位元素分情况讨论：

- 末位元素交换。此时初始的 `count = 1`
- 末位元素不交换。此时初始的 `count = 0`

​		随后，遍历两个数组，如果有不满足条件的元素，就让两个数组的对应位置交换。如果交换后还是不能满足条件，那说明这种方案是行不通的，返回 `-1`。

​		最后，从两种方案里选择成功的那一个，如果两种方案都能成功，就选择更小的那一个。

```python
class Solution(object):
    def count_swaps(self, nums1, nums2, is_swap):
        # 求交换次数
        count = 0
        if is_swap:  # 其实不需要真正的交换两个数组中的元素，计数即可
            last1, last2 = nums2[-1], nums1[-1]
            count += 1
        else:
            last1, last2 = nums1[-1], nums2[-1]
        for index in range(len(nums1) - 1):
            # 如果有一个数组不满足条件，就必须触发交换
            if nums1[index] > last1 or nums2[index] > last2:
                # 如果交换之后还是不满足条件，说明当前方案不成立
                if nums1[index] > last2 or nums2[index] > last1:
                    return -1
                count += 1
        return count

    def minOperations(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        # 末位元素交换
        ans1 = self.count_swaps(nums1=nums1[:], nums2=nums2[:], is_swap=True)
        # 末位元素不交换
        ans2 = self.count_swaps(nums1=nums1[:], nums2=nums2[:], is_swap=False)
        if ans1 < 0:
            if ans2 < 0:
                return -1
            else:
                return ans2
        else:
            if ans2 < 0:
                return ans1
            else:
                return min(ans1, ans2)
```

# 55. 跳跃游戏  & 45. 跳跃游戏 II

​		给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

​		判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

----

​		给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

​		每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

​		返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

## 1. 题目存在的问题

​		数组的下标是我们要到达的位置，对应的值是在该位置能够跳跃的最远距离。这点题干说得非常不清楚，最后需要到达的位置应该是 `len(nums) - 1`，和最后一个元素没有什么关系。

## 2.贪心算法

​		无论是找能否跳到还是跳跃的最少步数，都可以用覆盖范围的方法来求解。

​		对于能否跳到，只要覆盖范围能到达最后一个下标，就能跳到。

​		对于最少跳跃次数，在覆盖范围内尽可能跳得远一点，少增加几次跳跃，就能找到最少跳跃次数。需要记录两个数据：当前的最远覆盖范围 `curr_cover` 和下一个最远覆盖范围 `next_cover` 。遍历下标位置 `index`，更新下一个最远覆盖范围 `next_cover`，当 `index` 到达 `curr_cover` 时，说明当前这一步已经走到了尽头，如果此时还没能到达终点，就只能再跳一步，同时启用 `next_cover`。每次跳跃之后都需要判断 `curr_cover` 是否覆盖了终点，如果已经覆盖了终点，就不需要继续遍历了。

```python
class Solution(object):
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return 0
        steps = 0
        curr_cover = 0
        next_cover = 0
        for index in range(len(nums)):
            # 更新下一次能够跳跃到的最远距离
            next_cover = max(next_cover, index + nums[index])
            # 本次跳跃的范围到了尽头，只能再跳一次
            if index == curr_cover:
                steps += 1
                curr_cover = next_cover
                # 如果已经覆盖了终点，可以结束遍历
                if next_cover >= len(nums) - 1:
                    break
        return steps
```

# 1005. K次取反后最大化的数组和

​		给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

​		重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

​		以这种方式修改数组后，返回数组 **可能的最大和** 。

## 1. 问题

​		整体思路就是每次把最小的负数转换成正数，当没有负数，但是 `K` 值还有时，来回转换最小的数字，直到把次数耗光。

​		第一次做的时候，把数组从小到大排序，从最小的数字开始转换，但是这样存在一个问题：负数转换成正数之后，数组就不再有序了，所以每次都需要重新排序数组，造成时间复杂度很高。

## 2. 解决方案

​		把数组按照绝对值大小从大到小排序，第一遍从左到右遍历数组，把所有的负数变成正数，同时 `K` 减小。遍历完成之后，如果 `K` 还有次数，就把最右边的数字来回切换，直到次数耗完。

​		第一遍从左到右把负数变成正数之后，因为数组是按照绝对值排序的，转换完成之后数组还是有序的，并且最右边的数字是最小的。如果还有剩下的次数，正好把这个最小的数字来回切换。

```python
class Solution(object):
    def largestSumAfterKNegations(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        nums.sort(key=lambda x: abs(x), reverse=True)
        for index in range(len(nums)):
            if nums[index] < 0:
                nums[index] *= -1
                k -= 1
                if k == 0:
                    break
        while k > 0:
            nums[-1] *= -1
            k -= 1
        return sum(nums)
```

# 134. 加油站

## 1. 贪心思路

​		首先，在环路过程中，能获得的总油量和消耗的总油量是固定的（就是 `gas` 和 `cost` 的和），所以不能绕环的条件一开始就能判断（这点我也想到啦^^)。

​		接下来考虑要从哪个下标位置开始。用 `rest` 表示剩余油量，在每个加油站处，`rest[index] = gas[index] - cost[index]`。为了能够绕环，在整个遍历过程中，应该要求 `rest` 始终不能为负数，否则没法绕环。

​		这里，用和最大子数组和相似的贪心思路！累加 `rest` 的值，如果在某个 `index` 位置，累加和为负数，说明在 `[0, index]` 的区间内都不能作为起始位置，新的起始位置从 `index + 1` 开始算起。

​		完整代码：

```python
class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """
        if sum(gas) < sum(cost):
            return -1
        start_index, curr_sum = 0, 0
        for index in range(len(gas)):
            curr_sum += (gas[index] - cost[index])
            if curr_sum < 0:
                start_index = index + 1
                curr_sum = 0
        return start_index
```

注意：虽然只遍历了一遍，但是能保证找到的 `index` 位置一定是结果。因为从这个位置开始如果又发现了负数，从环的角度看，新的起始位置就又绕回了刚刚遍历过的位置，但是刚刚遍历过的位置已经没有结果了，那只能说明结果不存在，和整体的条件出现了矛盾。

## 2.一些补充说明

​		（2023年11月25日）在复习的时候突然想到，为什么到`index`的时候`rest`为负数，说明`index`及其之前的节点都不能作为起点了呢？如果说是因为能获得的油量变少了，同理消耗也变少了才对。

​		这里有一个简单的证明。假定一个加油站序列：`gas = [x1, x2, x3, ...], cost = [y1, y2, y3, ...]`，在`index = 1`的位置`rest < 0`，那么有：`x1 + x2 < y1 + y2`。由于在`index = 1`之前的所有位置，`rest >= 0`，所以`x1 >= y1`，那么可以推出`x2 < y2`，否则一定存在矛盾，由此可见，`index = 1`及其之前的位置都不能作为起点。其它的情况也可以以此为基础推导得到。

---

# 452.用最少数量的箭引爆气球

​		有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

​		一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

​		给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

## 1.思路

​		贪心。

​		尽可能把箭射到气球的重叠位置上，就能一次引爆尽可能多的气球。从整体上来看，最后需要的箭的数量就会更少。

​		我发现我的具体求解思路和代码随想录的有点不一样，不知道将来会不会出现问题，先记录一下。

​		我的想法是，先把气球排序，为了引爆当前`index`位置的气球，在最远位置的箭就是`end`位置的箭，然后继续遍历，让这个位置的箭先引爆气球，如果遍历到某个气球不能被这支箭引爆，就射出一支新的箭，箭的位置是这个`index`的`end`位置。

​		出现的问题是，采用`start`还是`end`来排序呢？

​		我第一遍做的时候，是用`start`来排序的，但是这样会没法 AC：如果出现`[7, 12], [9, 10]`的样例，遍历到`[7, 12]`的时候会把下一支箭的位置更新为 12，再遍历到`[9, 10]`的时候就得射出一支新的箭了，但是实际上在 10 的位置射出一支箭可以直接引爆两个气球，因为这两个气球是互相嵌套的。

​		所以，我换成用`end`来排序，思路和上述贪心的思路相同，最后就能 AC 了。

## 2.代码随想录的解决方案

​		代码随想录上的解题方案按照`start`来排序，同时去找前后两个气球的重叠位置，以重叠位置较小的那个`end`作为箭射出的位置。（这么一想，或许和我的思路也差不多？）

---

# 435.无重叠区间

​		给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

## 1.最初的思路

​		最初我想把区间按照`start`从前到后排序，当两个区间重叠时，就删除较长的那一个。

​		这种贪心的思路是错误的：对于区间`[58, 95], [66, 98], [82, 97], [95, 99]`，按照上述逻辑会删除 3 个区间（因为上来就会把`[58, 95]`给删除，剩下 3 个区间全都相互重叠），但是实际上只删除 2 个区间即可（`[66, 98], [82, 97]`）。

## 2.正确的思路

​		删除的区间 = 全部区间 - 互不重叠的区间。

​		换言之，想要被删除的区间尽可能少，互不重叠的区间需要尽可能多。因此，应该按照`end`从前到后排序。

​		当遇到互不重叠的区间时，计数加 1，同时更新当前区间的`end`位置。

```python
class Solution(object):
    def eraseOverlapIntervals(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: int
        """
        intervals.sort(key=lambda interval: (interval[1], interval[0]))
        count = 1
        pre_end = intervals[0][1]
        for index in range(1, len(intervals)):
            # 遇到互不重叠的区间
            if intervals[index][0] >= pre_end:
                count += 1
                pre_end = intervals[index][1]
        return len(intervals) - count
```

---

# 763.划分字母区间

​		给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

​		注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

​		返回一个表示每个字符串片段的长度的列表。

## 1.我的思路

​		和重叠区间的思路差不多：先统计每个字母出现的起始和终点位置，然后找到所有的无重叠包裹区间。

```python
class Solution(object):
    def partitionLabels(self, s):
        """
        :type s: str
        :rtype: List[int]
        """
        result_list = []
        # 统计每个字母的起止位置
        char_dict = {}
        for index in range(len(s)):
            char = s[index]
            char_dict.setdefault(char, [index, index])
            char_dict[char][1] = index
        index_list = list(char_dict.values())
        index_list.sort(key=lambda item: item[0])
        start, end = index_list[0][0], index_list[0][1]
        for i in range(1, len(index_list)):
            if index_list[i][0] > end:
                # 出现了新的区间
                result_list.append(end - start + 1)
                start, end = index_list[i][0], index_list[i][1]
            else:
                # 统计最远位置
                # 因为要把之前出现过的所有字母都包裹其中
                end = max(end, index_list[i][1])
        result_list.append(end - start + 1)
        return result_list
```

## 2.代码随想录的解决方案

​		只需要统计字母出现的最终位置，然后遍历字符串，每遍历一个字母，计算当前字符串的最远位置。当遍历到下标和最远位置相等的位置时，说明从这里分割，前面出现的所有字母都能被包裹其中（因为已经到达最远位置了！）。

![image-20231122102227646](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231122102227646.png)

```python
class Solution(object):
    def partitionLabels(self, s):
        """
        :type s: str
        :rtype: List[int]
        """
        result_list = []
        char_dict = {}
        # 统计当前字母出现的最后位置
        for index in range(len(s)):
            char = s[index]
            char_dict.setdefault(char, index)
            char_dict[char] = index
        start, end = 0, 0
        for index in range(len(s)):
            char = s[index]
            end = max(end, char_dict[char])
            # 如果当前下标位置和之前出现字母的最远位置相等
            # 说明在当前下标位置分割，可以把之前所有出现的字母划分到一个片段中
            if index == end:
                result_list.append(end - start + 1)
                start, end = end + 1, end + 1
        return result_list
```

这样能加快运行速度，同时降低内存消耗。

---

# 738.单调递增的数字

​		当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

​		给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

## 1.第一次提交出现的问题

​		一开始就想到，从低位开始往高位遍历，一旦遇到`n[i] < n[i - 1]`的情况，为了让数字尽可能大，并且比原始数字要小，需要把`n[i]`设置为 9，`n[i - 1]`减 1。

​		在样例`n = 100`时，正确答案为 99，上述方法得到的答案为 90。

​		出错的原因在于，当遍历 0 和 0 的时候，不会发生变化，但是遍历到 0 和 1 的时候，0 变成 9，1 变成 0，这个时候，0 和 9 又不满足关系了。

​		所以当把`n[i]`设置为 9 的时候，后面的低位也需要全部设置为 9， 这样才能保证满足递增数字关系。

## 2.代码

```python
class Solution(object):
    def monotoneIncreasingDigits(self, n):
        """
        :type n: int
        :rtype: int
        """
        n_bit = []
        rest = n
        while rest > 0:
            n_bit.append(rest % 10)
            rest = int(rest / 10)
        for index in range(len(n_bit) - 1):
            if n_bit[index] < n_bit[index + 1]:
                # 在这个位置发生了变化
                n_bit[index] = 9
                # 需要将之前遍历过的位数都变成9，以保证递增序列
                j = index - 1
                while j >= 0:
                    n_bit[j] = 9
                    j -= 1
                n_bit[index + 1] -= 1
        new_n = 0
        for index in range(len(n_bit) - 1, -1, -1):
            new_n *= 10
            new_n += n_bit[index]
        return new_n
```

---

# 100142. 交换得到字典序最小的数组

​		给你一个下标从 **0** 开始的 **正整数** 数组 `nums` 和一个 **正整数** `limit` 。

​		在一次操作中，你可以选择任意两个下标 `i` 和 `j`，**如果** 满足 `|nums[i] - nums[j]| <= limit` ，则交换 `nums[i]` 和 `nums[j]` 。

​		返回执行任意次操作后能得到的 **字典序最小的数组** 。

​		如果在数组 `a` 和数组 `b` 第一个不同的位置上，数组 `a` 中的对应字符比数组 `b` 中的对应字符的字典序更小，则认为数组 `a` 就比数组 `b` 字典序更小。例如，数组 `[2,10,3]` 比数组 `[10,2,3]` 字典序更小，下标 `0` 处是两个数组第一个不同的位置，且 `2 < 10` 。

## 1. 最初的想法

​		第一次做的时候觉得可以用贪心算法去模拟：从最高位开始，依次换成后续数字中满足条件的最小值，得到的数组应该就是字典序最小的数组。

​		这样做的问题在于，实际上在每个位置上的交换并不是只执行一次就能得到最终结果的。例如：`nums = [4, 52, 38, 59, 71, 27, 31, 83, 88, 10], limit = 14`，对于`index = 1`的位置，会进行如下交换：

```
52 → 38
38 → 27
```

也就是说，换过来的数字（38）对于原来在这个位置上的数字（52）是满足条件的最小值，但是对于这个新的数字（38）不一定是（后续还有更小的 27）。

## 2. 解决方案

​		正确的思路是分组排序。

​		首先，把原始数组排序，满足条件的数字分成一组，注意，为了交换，同时需要记录它们的下标。然后，对于每组中的数字，把它们排序之后，放回原来的位置上。

​		例如，对于上面的例子：

```
第一个分组：(0, 4), (9, 10)
第二个分组：(5, 27), (6, 31), (2, 38), (1, 52), (3, 59), (4, 71)
第二个分组：(7, 83), (8, 88)
```

每个分组中前后两个数字间的差距都小于等于`limit`。把第一个分组中的所有数字，按照大小顺序放回其坐标上，也就是：

```
第一个分组：
0: 4
9: 10

第二个分组：
1: 27
2: 31
3: 38
4: 52
5: 59
6: 71

第三个分组：
7: 83
8: 88
```

这就是最终的答案。

​		为什么这种方法能够实现，我的感觉是，因为每个分组中前后两个数字之间的差距都小于等于`limit`，两两交换之下总可以把该分组中最小的数字换到最前面。所以也能知道为什么要记录下标，就是为了保证交换一定是发生在同组之内的，组间因为不满足条件，即使有更小的数字也不能交换（例如上一个例子中的 10 是永远换不到前面的）。

## 3. 完整代码

```python
class Solution(object):
    def lexicographicallySmallestArray(self, nums, limit):
        """
        :type nums: List[int]
        :type limit: int
        :rtype: List[int]
        """
        num_list = list(enumerate(nums))
        # 排序，同时记录下标
        num_list.sort(key=lambda item: item[1])
        n = len(nums)
        a = [num_list[0][0]]
        b = [num_list[0][1]]
        for i in range(1, n):
            # 找同组元素
            if num_list[i][1] - num_list[i-1][1] <= limit:
                a.append(num_list[i][0])
                b.append(num_list[i][1])
            else:
                a.sort()
                m = len(a)
                # 同组中的元素按照从小到大的顺序放回原位
                for j in range(m):
                    nums[a[j]] = b[j]
                # 分组更新
                a = [num_list[i][0]]
                b = [num_list[i][1]]
        # 最后一个分组手动更新
        a.sort()
        m = len(a)
        for j in range(m):
            nums[a[j]] = b[j]
        return nums
```

---

# 62. 不同路径

​		一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

​		机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

​		问总共有多少条不同的路径？

![image-20231129100325150](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231129100325150.png)

## 1. 初始化的小问题

​		我第一遍自己做的时候，只初始化了`dp[0][1]`和`dp[1][0]`两个位置的数值，结果每行遍历的时候，还需要判断`i - 1`和`j - 1`是否合法，不仅耗时变长了，内存损耗也变大了……还需要对`m = 1`或`n = 1`的情况单独判断……

​		其实，`dp`数组的第一行和第一列都可以直接初始化为 1，因为机器人只能往右或者往下走，整个第一行和第一列都只有一种走法。这样再从左到右遍历的时候，就可以直接都从 1 开始，`i - 1`和`j - 1`在任何情况下都是合法的了。

## 2. 简化后的代码

```python
class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 这里：初始化的方法
        for i in range(1, m):
            dp[i][0] = 1
        for j in range(1, n):
            dp[0][j] = 1
        # 动态规划
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```

---

# 63. 不同路径 II

​		一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

​		机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

​		现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

​		网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

![image-20231130100757403](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231130100757403.png)

## 1. 处理障碍物的小问题

​		因为最开始的时候把整个`dp`数组初始化为全 0，所以在处理障碍物上有一些小技巧。

​		对于初始化第一行和第一列来说，如果在第一行和第一列上出现了障碍物，那么这个位置和之后的位置就都不可达了，这个时候可以直接跳过。

```python
for i in range(m):
	if obstacleGrid[i][0] == 1:
		break
	dp[i][0] = 1
```

​		对于递推计算的时候，如果出现了障碍物，那么这个位置不可达，可以直接跳过，但是之后的位置依然有可能可达，所以要继续循环。说简单点，就是当这个位置没有障碍物的时候才计算，否则直接用之前初始化的 0 就行。

```python
for i in range(1, m):
	for j in range(1, n):
		if obstacleGrid[i][j] == 0:
			dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```

如果真的要重新赋值一下 0 的话，在初始化的时候，考虑为 0 的情况比为 1 的情况更好写。

## 2. 简化后的代码

```python
class Solution(object):
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 初始化
        for i in range(m):
            # 这里：当有一个障碍的时候，后面的位置就都不可达了，直接用原来的初始值 0 就行
            if obstacleGrid[i][0] == 1:
                break
            dp[i][0] = 1
        for j in range(n):
            if obstacleGrid[0][j] == 1:
                break
            dp[0][j] = 1
        for i in range(1, m):
            for j in range(1, n):
                # 这里：反正之前初始化的时候就是初始化为 0。当不满足条件的时候直接跳过就行了，不需要再赋值一遍 0
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```

---

# 343. 整数拆分

​		给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

​		返回 *你可以获得的最大乘积* 。

## 1. 思路

​		这个题目比之前的路径等等题目都要难，主要是想不到递推公式怎么写。

​		递推五步：

- `dp`和`i`的含义
  - `dp`是最大乘积
  - `i`是需要拆分的整数
  - `dp[i]`表示拆分整数`i`能够获得的最大乘积
- 递推公式
  - `dp[i] = max(dp[i], j * (i - j), j * dp[i - j])`
  - `j`从1遍历到`i - 1`
  - 表示先从`i`里面拆出一个`j`，那么剩下的部分可以不拆分；如果要拆分，一定要选择之前推导出来的乘积最大的拆分方式。这就是和之前状态之间的关系
  - 递推里面有遍历也是可能出现的情况
- 初始化
  - `dp[1] = 1, dp[2] = 1`
- 推导方向
  - 从前向后
- 手动推导一部分（略）

## 2. 代码

```python
class Solution(object):
    def integerBreak(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0 for _ in range(n + 1)]
        dp[1], dp[2] = 1, 1
        for i in range(3, n + 1):
            for j in range(1, i):
                dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
        return dp[n]
```

---

# 100153. 需要添加的硬币的最小数量

​		给你一个下标从 **0** 开始的整数数组 `coins`，表示可用的硬币的面值，以及一个整数 `target` 。

​		如果存在某个 `coins` 的子序列总和为 `x`，那么整数 `x` 就是一个 **可取得的金额** 。

​		返回需要添加到数组中的 **任意面值** 硬币的 **最小数量** ，使范围 `[1, target]` 内的每个整数都属于 **可取得的金额** 。

​		数组的 **子序列** 是通过删除原始数组的一些（**可能不删除**）元素而形成的新的 **非空** 数组，删除过程不会改变剩余元素的相对位置。

## 1. 最初的想法

​		第一次做的时候，纠结在两个问题上：

- 如何判断当前数组能构成的所有金额？
- 知道还缺少哪些金额之后，如何添加硬币，使得所需的硬币数量最少？

​		当时甚至想到了硬币可以从小到大排序，当需要添加硬币时，应该添加上限，感觉就差一点点就能找到解法了。

## 2. 思路

​		首先，把整数数组`coins`从小到大排序。

​		其次，遍历`coins`。如果之前可取得的金额范围是`[0, s]`，并且`s < target`，当前遍历的硬币金额是`x`，那么分类讨论：

- 如果`x <= s + 1`，那么可取得的金额范围可以扩展到`[0, s + x]`，因为在`s`的地方是连续的，而只要把`x`依次加上`[0, s]`中的组合，就可以得到新的金额范围`[0, s + x]`了。不需要添加新的硬币，按顺序遍历下一枚硬币。
- 如果`x > s + 1`，或者当前已经没有能遍历的硬币了，那么必须添加一个金额为`s + 1`的硬币，同时可取得的金额范围会被扩展到`[0, 2 * s + 1]`。下一次在再遍历面值为`x`的硬币。

​		最后，返回需要添加的硬币数量即可。

## 3. 代码

```python
class Solution(object):
    def minimumAddedCoins(self, coins, target):
        """
        :type coins: List[int]
        :type target: int
        :rtype: int
        """
        coins.sort()
        # 需要添加的硬币数
        count = 0
        # 遍历硬币的索引
        i = 0
        # 上限，目前可取得的金额范围为：[0, s]
        s = 0
        while s < target:
            if i < len(coins) and coins[i] <= s + 1:
                # 更新目前可取得的金额范围为：[0, s + x]
                s += coins[i]
                i += 1
            else:
                # 为了能够达到 target 必须添加一枚面值为 s 的硬币
                count += 1
                # 更新目前可取得的金额范围为：[0, 2 * s + 1]
                s = 2 * s + 1
        return count
```

---

# 100145. 统计完全子字符串

​		给你一个字符串 `word` 和一个整数 `k` 。

​		如果 `word` 的一个子字符串 `s` 满足以下条件，我们称它是 **完全字符串：**

- `s` 中每个字符 **恰好** 出现 `k` 次。
- 相邻字符在字母表中的顺序 **至多** 相差 `2` 。也就是说，`s` 中两个相邻字符 `c1` 和 `c2` ，它们在字母表中的位置相差 **至多** 为 `2` 。

​		请你返回 `word` 中 **完全** 子字符串的数目。

​		**子字符串** 指的是一个字符串中一段连续 **非空** 的字符序列。

## 1. 最初的想法

​		拿到这个题目的时候，第一反应是创造前缀，通过前缀相减得到子字符串。

​		不仅代码特别复杂，而且也没能 AC。

​		实际上子字符串的问题还可以通过滑动窗口来求解，特别是这个题目的子字符串中只有小写英文字母，也就是最多只有 26 种不同的情况，遍历完全部也不会有很高的时间复杂度。

## 2. 思路

​		首先，按照条件 2 对字符串分组，这也是为了降低计算复杂度。因为两个相邻字符的位置相差不超过 2，那么在相差超过 2 的地方就可以将字符串分开，分别计算它们内部的完全子字符串个数，然后相加。条件 2 保证完全子字符串一定不会横跨上述分组之后的字符串。

​		其次，在每个子字符串内部查找完全子字符串。从 1 到 26 遍历字母的个数，如果当前字母个数为`m`，那么滑动窗口的长度为`l = m * k`。从子字符串的左边开始滑动滑动窗口，对于每个窗口内部，统计频次等于`k`的字母个数，如果为`m`，也就是当前窗口内所有字母的出现次数都为`k`，满足条件 1 ，找到了一个完全子字符串。

## 3. 代码

​		下述代码超时，但是逻辑完全正确。

```python
from collections import Counter


class Solution(object):
    def countSubStrings(self, word, start, end, k):
        # 返回当前子字符串中的完全子字符串数量
        result = 0
        # 因为只有 26 个英文字母，可以统计
        for m in range(1, 27):
            # 滑动窗口的长度
            l = m * k
            # 如果当前字符串的长度比滑动窗口的长度要短，那么直接结束即可
            if end - start + 1 < l:
                break
            # 初始化滑动窗口
            left, right = start, start + l - 1
            while right <= end:
                counter = Counter(word[left:right+1])
                # 滑动窗口内是完全子字符串
                above_char = 0
                for values in counter.values():
                    if values == k:
                        above_char += 1
                if above_char == m:
                    result += 1
                # 滑动窗口移动
                left += 1
                right += 1
        return result

    def countCompleteSubstrings(self, word, k):
        """
        :type word: str
        :type k: int
        :rtype: int
        """
        # 完全子字符串
        result = 0
        # 按照 distance <= 2 的条件对字符串进行分组
        # 因为完全子字符串是不可能跨组的
        start, end = 0, 1
        while end < len(word):
            if abs(ord(word[end]) - ord(word[end - 1])) > 2:
                # 计算每一个组中的完全字符串数量
                result += self.countSubStrings(word=word, start=start, end=end - 1, k=k)
                start = end
            end += 1
        # 最后一个字符串要单独考虑一下
        result += self.countSubStrings(word=word, start=start, end=end-1, k=k)
        return result
```

---

# 96. 不同的二叉搜索树

​		给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

## 1. 最初的思路

​		审题！是二叉搜索树，所以左子树上的节点一定比根节点要小，右子树上的节点一定比根节点要大。

​		不要想成二叉树的形状不同了，那个求解不出来的！

## 2. 思路

​		只要解决了二叉搜索树的问题，就基本上解决了全部的问题。

​		动态规划五步：

- `dp[i]`表示有`i`个节点的二叉搜索树的种数；
- 递推公式：`dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + ... + dp[i - 1] * dp[0]`
  - 每一项表示以某个节点`j`为根节点时，左子树有`j - 1`个节点，有`dp[j - 1]`种情况；右子树有`i - j`个节点，有`dp[i - j]`种情况。
  - `j`的取值范围从 `1 ~ i`。
- 初始化：初始化`dp[o] = 1`即可。
- 推导方向：从小向大推导。

## 3. 代码

```python
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0 for _ in range(n + 1)]
        dp[0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                dp[i] += dp[j - 1] * dp[i - j]
        return dp[-1]
```

---

# 0-1 背包

​		小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

​		小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

​		第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。

​		第二行包含 M 个正整数，代表每种研究材料的所占空间。 

​		第三行包含 M 个正整数，代表每种研究材料的价值。

​		输出一个整数，代表小明能够携带的研究材料的最大价值。

## 1. 思路

​		经典的动态规划题目，0-1 背包。

​		动态规划五步：

- `dp[i][j]`：表示有`i`件物品，背包容量为`j`时，能够获得的最大价值。
- 递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`
  - 对于有`i`件物品，背包容量为`j`的情况，分类讨论：
  - 如果第`i`件物品不装进背包，那么`dp[i][j] = dp[i - 1][j]`
  - 如果第`i`件物品要装进背包，那么`dp[i][j] = dp[i - 1][j - weight[i]] + value[i]`
    - 注意，无论是哪种情况，都是`i - 1`！
    - 因为对于第二种情况而言，如果当前第`i`件物品要装，那么前`i-1`件物品能够占的容量就不能超过`j-weight[i]`。
- 推导方向：先遍历物品也可以，先遍历背包容量也可以。
- 初始化：
  - `dp[i][0]`全部初始化为 0
  - `dp[0][j]`全部初始化为 0
  
  （背包问题：在某个上限的条件下，在某个集合中选取元素，要求选取到的元素的总和最大）

## 2. Python 接收控制台输入

​		卡码网不像力扣一样有一个固定的框架，是要自行处理控制台的输入，然后输出结果的。

​		`Python`接收控制台输入：`input()`，但是不能处理输入换行的情况。

​		如果输入有多行，可以写多个`input()`，依次接收。

​		`input()`接收输入数据默认是字符串形式，通过`int()`可以转换成整型。

​		如果每行有多个数据，可以用`split()`分割，然后再用`list`转换成数组。

```python
_, bag_weight = [int(num) for num in input().split()]
weight = [int(num) for num in input().split()]
value = [int(num) for num in input().split()]
sol = Solution()
print(sol.bag_problem(w=weight, v=value, bag_weight=bag_weight))
```

## 3. 完整版代码

```python
class Solution:
    def bag_problem(self, w, v, bag_weight):
        """
        0-1 背包问题
        :param w: List[int]
        :param v: List[int]
        :param bag_weight: int
        :return: int
        """
        dp = [[0 for _ in range(bag_weight + 1)] for _ in range(len(w) + 1)]
        for i in range(1, len(w) + 1):
            for j in range(1, bag_weight + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1] if j >= w[i - 1] else 0)
        return dp[-1][-1]


if __name__ == '__main__':
    _, bag_weight = [int(num) for num in input().split()]
    weight = [int(num) for num in input().split()]
    value = [int(num) for num in input().split()]
    sol = Solution()
    print(sol.bag_problem(w=weight, v=value, bag_weight=bag_weight))
```

## 3. 滚动数组

​		从上面的递推公式可以看出，`dp[i][j]`默认从上一行中得到(`dp[i-1][j]`)，所以，可以用一维数组代替二维数组。将递推公式转换为：`dp[j] = max(dp[j], dp[j - w[i]] + v[i])`。

​		对于循环求解的过程不发生变化，还是两层`for`循环，但是现在外层必须是物品编号`i`，内层必须是背包体积`j`，而且背包体积的遍历应该是倒过来的。

​		关于为什么`j`要倒过来遍历，举例：

- `w = [1, 3, 4]`
- `v = [15, 20, 30]`
- `bag_weight = 4`

如果像是二维`dp`那样正序遍历：

- `dp[1] = max(dp[1], dp[0] + 15) = 15`
- `dp[2] = max(dp[2], dp[1] + 15) = 30`

可以看出，物品会被选多次（`dp[2]`本来应该是 15，现在变成了 30），所以只能反过来遍历。

​		（可以这样考虑。本身`dp[i][j]`是从上一行的对应元素或者上一行的前面某个元素得到的。当转换成滚动数组时，本行实际上是用上一行的值初始化的，按照原来的对应关系，需要保证在求`dp[j]`时，之前的元素保持上一行的值不变，因此必须倒着遍历。）

```python
class Solution:
    def bag_problem(self, w, v, b):
        """
        滚动数组求解 0-1 背包问题。
        :param w: List[int]
        :param v: List[int]
        :param b: int
        :return: int
        """
        dp = [0 for _ in range(b + 1)]
        for i in range(1, len(w) + 1):
            for j in range(b, w[i - 1] - 1, -1):
                dp[j] = max(dp[j], dp[j - w[i - 1]] + v[i - 1] if j >= w[i - 1] else 0)
        return dp[-1]
```

---

# 416. 分割等和子集

​		给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

## 1. 最初的思路

​		关键在于谁是背包的重量，谁是背包的价值？

​		开始的时候，把子集中元素的个数作为背包的重量，假定每一个元素的重量都为 1，但是这样是有问题的：0-1背包问题的递推公式是求最大价值的，上述方法会默认取能取的最大价值，也就是最大的元素……但是取最大的元素不一定能得到两个等和的子集。

## 2. 思路

​		`nums`既是物品的重量也是物品的价值。也就是说，把问题转换成，现在有一个容量大小为`target = sum(nums) // 2`的背包，要装`nums`里的元素；在背包容量允许的范围内，装的元素的价值要尽可能大（尽可能接近`target`。同时因为重量和价值是一个数值，所以永远不可能超过）。如果背包中的元素之和也为`target`，说明背包正好装满，也就找到了等和子集。

## 3. 代码

​		别忘了递推公式中的判断条件。

```python
class Solution(object):
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        if sum(nums) % 2 != 0:
            return False
        target = sum(nums) // 2
        dp = [[0 for _ in range(target + 1)] for _ in range(len(nums) + 1)]
        for i in range(1, len(nums) + 1):
            for j in range(1, target + 1):
                # 物品能否真的装进背包需要判断条件
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1] if j >= nums[i - 1] else 0)
                if j == target and dp[i][j] == target:
                    return True
        return False
```

---

# 417. 最后一块石头的重量 II

​		有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

​		每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

​		最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

## 1. 问题转换

​		这道题可以转换成416. 分割等和子集问题。每次选出任意两块石头，一起粉碎，可以理解成把一堆石头分成重量尽可能接近的两堆，让这两堆石头相撞（重量相减），得到的就是剩下的石头。那么，对于这两堆石头中的一堆，可以视为一个0-1 背包：在背包容量不超过石头重量总和的一半条件下，尽可能装石头，让石头的重量接近石头重量总和的一半。

​		和分割等和子集一样，`stones`既是物品的重量，又是物品的价值。

​		（背包的体积是上限，有可能不能到达，背包中物品的价值是实际由选取物品得到的）

## 2. 代码

```python
class Solution(object):
    def lastStoneWeightII(self, stones):
        """
        :type stones: List[int]
        :rtype: int
        """
        target = int(sum(stones) / 2)
        dp = [[0 for _ in range(target + 1)] for _ in range(len(stones) + 1)]
        for i in range(1, len(stones) + 1):
            for j in range(1, target + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i - 1]] + stones[i - 1] if j >= stones[i - 1] else 0)
        return (sum(stones) - dp[-1][-1]) - dp[-1][-1]
```

---

# 494. 目标和

​		给你一个非负整数数组 `nums` 和一个整数 `target` 。

​		向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

​		返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

## 1. 问题转换

​		首先，如果`sum(nums) < abs(target)`，说明即使把整个非负整数数组全添加正号（此时最大）或者全添加负号（此时最小）都不能满足`target`，则不存在满足要求的表达式。

​		假定添加正号的整数之和为`left`，添加负号的整数之和为`right`，则有`left + right = sum(nums), left - right = target`，可以推出`left = (sum(nums) + target) // 2`。

​		再做判断：如果不能整除，说明也不存在满足要求的表达式。

​		如果能整除，问题转换成，如何选择`nums`中的整数，使其和为`left`，求这样的选择有多少种（`right`就是选剩下的整数）。

​		动态规划：

- `dp[i][j]`：前`i`个整数，凑成和为`j`，有多少种凑法。
- 递推公式：`dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]`（注意：物品编号从 1 开始）
  - 如果不选择`nums[i - 1]`，那么就要用前`i - 1`个元素凑出和`j`，一共有`dp[i - 1][j]`种凑法；
  - 如果选择`nums[i - 1]`，那么就要用前`i - 1`个元素凑出和`j - nums[i - 1]`，一共有`dp[i - 1][j - nums[i - 1]]`种凑法。
- 初始化：本题的初始化和0-1背包有些不同。初始化`dp[0][0] = 1`。
  - 为什么初始化为 1？为了让递推公式能够正常推导，如果这里初始化为 0 了，下面就会全都是 0，没法得到正确的结果。
  - 为什么不初始化`dp[i][0]`？因为对于`nums[i]`，和物品的重量不同，可以取值为 0，也就是说要凑 0，也可以有很多种不同的凑法，所以不能直接全部初始化为 0 或者 1。
- 推导方向：从小到大。

## 2. 代码

```python
class Solution(object):
    def findTargetSumWays(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        count = 0
        if sum(nums) < abs(target):  # 数组中的元素最大也不能凑到 target
            return count
        if (sum(nums) + target) % 2 > 0:  # 不能构造成功
            return count
        bag_size = (sum(nums) + target) // 2
        dp = [[0 for _ in range(bag_size + 1)] for _ in range(len(nums) + 1)]
        # 这个题目的初始化和普通的 0-1 背包不同
        dp[0][0] = 1
        for i in range(1, len(nums) + 1):
            for j in range(bag_size + 1):
                if j >= nums[i - 1]:  # 当选中 nums[i - 1] 时
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]
```

---

# 完全背包

## 1. 思路

​		完全背包和 0-1 背包的区别在于，物品的数量是无限的，也就是每一个物品可以取无限次。

​		递推公式：`dp[i][j] = max(dp[i - 1][j] + dp[i][j - w[i]] + v[i])`（二维数组）`dp[j] = max(dp[j], dp[j - w[i]] + v[i])`（滚动数组）

​		二维递推公式的推导参考：http://t.csdnimg.cn/PQHE9 重点在这里：

![image-20231214094659602](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231214094659602.png)

​		对于滚动数组，递推公式的形式没有发生变化，但是在遍历背包的时候，现在要从前向后遍历（要先算出`dp[i][j - w[i]]`）。

## 2. 代码

​		二维数组：

```python
def complete_bag_problem(items, bag_size):
    n = len(items)
    dp = [[0 for _ in range(bag_size + 1)] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, bag_size + 1):
            if j >= items[i - 1][0]:
                # 这里：递推公式有变化！
                dp[i][j] = max(dp[i - 1][j], dp[i][j - items[i - 1][0]] + items[i - 1][1])
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[-1][-1]
```

​		滚动数组：

```python
def complete_bag_problem(items, bag_size):
    n = len(items)
    dp = [0 for _ in range(bag_size + 1)]
    for i in range(n):
        # 这里：现在是从前向后遍历了！
        for j in range(items[i][0], bag_size + 1):
            dp[j] = max(dp[j], dp[j - items[i][0]] + items[i][1])
    return dp[-1]
```

---

# 518. 零钱兑换 II

​		给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

​		请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

​		假设每一种面额的硬币有无限个。 

​		题目数据保证结果符合 32 位带符号整数。

## 1. 思路

​		和目标和问题一样，只不过把 0-1 背包问题变成了完全背包问题。

- `dp[i][j]`表示用前`i`种硬币，凑出金额为`j`的组合数；
- 递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]]`
- 初始化：`dp[0][0] = 1, dp[0][j] = 0`
- 遍历方向：均为从小到大遍历。

## 2. 有关遍历顺序的问题

​		对于先遍历物品还是先遍历背包容量的问题。

​		用二维`dp`数组的时候，无论先遍历哪一个都没有区别。

​		用滚动数组的时候，先遍历物品，后遍历背包容量，得到的是组合数；先遍历背包容量，后遍历物品，得到的是排列数。

​		（为什么会是这样……我试着推导了一下，发现在先遍历背包容量，后遍历物品的情况下，`{1, 2}`和`{2, 1}`会被分成两次单独计数，也就是变成了排列问题）

## 3. 代码

```python
# 二维 dp 数组
class Solution(object):
    def change(self, amount, coins):
        """
        :type amount: int
        :type coins: List[int]
        :rtype: int
        """
        dp = [[0 for _ in range(amount + 1)] for _ in range(len(coins) + 1)]
        dp[0][0] = 1
        for i in range(1, len(coins) + 1):
            for j in range(amount + 1):
                dp[i][j] = dp[i - 1][j]
                if j >= coins[i - 1]:
                    dp[i][j] += dp[i][j - coins[i - 1]]
        return dp[-1][-1]
```

```python
# 一维滚动数组
class Solution(object):
    def change(self, amount, coins):
        """
        :type amount: int
        :type coins: List[int]
        :rtype: int
        """
        dp = [0 for _ in range(amount + 1)]
        dp[0] = 1
        # 这里：必须先遍历物品，后遍历背包容量
        for i in range(1, len(coins) + 1):
            for j in range(coins[i - 1], amount + 1):
                dp[j] += dp[j - coins[i - 1]]
        return dp[-1]
```

---

# 100151. 使数组成为等数数组的最小代价

​		给你一个长度为 `n` 下标从 **0** 开始的整数数组 `nums` 。

​		你可以对 `nums` 执行特殊操作 **任意次** （也可以 **0** 次）。每一次特殊操作中，你需要 **按顺序** 执行以下步骤：

- 从范围 `[0, n - 1]` 里选择一个下标 `i` 和一个 **正** 整数 `x` 。
- 将 `|nums[i] - x|` 添加到总代价里。
- 将 `nums[i]` 变为 `x` 。

​		如果一个正整数正着读和反着读都相同，那么我们称这个数是 **回文数** 。比方说，`121` ，`2552` 和 `65756` 都是回文数，但是 `24` ，`46` ，`235` 都不是回文数。

​		如果一个数组中的所有元素都等于一个整数 `y` ，且 `y` 是一个小于 `109` 的 **回文数** ，那么我们称这个数组是一个 **等数数组** 。

​		请你返回一个整数，表示执行任意次特殊操作后使 `nums` 成为 **等数数组** 的 **最小** 总代价。

## 1. 思路

​		（回过头来看题解，发现最初的想法是正确的，差一点就能做出来了。）

​		首先，要找`nums`的中位数，这里有两种情况，第一种情况中位数唯一，第二种情况中位数不唯一。可以用`n`和`n - 1`的方法把它们放在一起考虑：

```python
nums.sort()
n = len(nums)
mid_idx1, mid_idx2 = (n - 1) // 2, n // 2
lower, upper = nums[mid_idx1], nums[mid_idx2]
```

如果中位数唯一（`n`为奇数），则`mid_idx1 = mid_idx2`。

​		其次，找到中位数之后怎么找回文数。其实不需要多麻烦的凑出来，直接用一个`while`循环在左右去找就可以：

```python
while not self.check_palindrome(num=lower):
	lower += 1
while not self.check_palindrome(num=upper):
	upper -= 1
```

注意这里，如果中位数唯一（`lower = upper`），则找到的回文数正好是这个中位数左右两侧的最近回文数；如果中位数不唯一，则找到的回文数要么被夹在两个中位数之间，要么分布在两个中位数左右两侧最近的位置，正好把所有可能的情况都考虑进去了。

​		最后就很简单的看凑到哪个回文数的代价更小即可。

## 2. 代码

```python
class Solution(object):
    def check_palindrome(self, num):
        # 判断一个数字是否为回文数
        num_list = []
        rest = num
        while rest > 0:
            num_list.append(rest % 10)
            rest = rest // 10
        left, right = 0, len(num_list) - 1
        while left < right:
            if num_list[left] != num_list[right]:
                return False
            left += 1
            right -= 1
        return True

    def compute_count(self, nums, p):
        # 计算代价
        count = 0
        for i in range(len(nums)):
            count += abs(p - nums[i])
        return count

    def minimumCost(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        n = len(nums)
        mid_idx1, mid_idx2 = (n - 1) // 2, n // 2
        lower, upper = nums[mid_idx1], nums[mid_idx2]
        while not self.check_palindrome(num=lower):
            lower += 1
        while not self.check_palindrome(num=upper):
            upper -= 1
        return min(self.compute_count(nums=nums, p=lower), self.compute_count(nums=nums, p=upper))
```

---

# 139. 单词拆分

​		给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

​		**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

## 1. 思路

​		因为跟在背包问题后面，所以很容易想到是个完全背包问题，而且是排列数。字符串 `s` 是背包的容量，主要问题在于物品是不是 `wordDict`。

​		如果把 `wordDict` 当做物品，在写递推关系的时候会很困难，因为每次选择一个物品，都会产生一个剩余的字符串，而这个字符串在上一层不一定计算过结果，开始的时候就是卡在了这个地方。

​		举个例子，`s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]`。当遍历到 `"sand"` 时，如果选上，那么会产生 `"catog"` 的字符串，而这个字符串在之前并没有做过判断，所以不能判断当前是否能够拼接成功。

​		其实这个题目和之前做过的回文串回溯问题和整数拆分很像。对于一个长为 `j` 的字符串，可以从 `i` 的位置拆分，分成长为 `i` 的字符串和剩下的 `s[i:j]`。`dp[i]` 在之前已经判断过能否利用字典中的单词拼接出来，现在只需要判断 `s[i:j]` 能否用字典拼接出来就可以了。如果也能，说明长为 `j` 的字符串可以被拼接出来；否则则不行。

​		所以实际上的物品应该是字符串的分割位置。

- `dp[j]`表示长为 `j` 的字符串能否用字典中的单词拼接出来。
- 递推公式：`dp[j] = dp[j] or (dp[i] and str[i:j] in wordDict)`。
- 初始化：`dp[0] = true`。
- 递推方向：从小到大，先 `j` 后 `i`（因为是排列问题）。

## 2. 代码

```python
class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        dp = [False for _ in range(len(s) + 1)]
        dp[0] = True
        for j in range(1, len(s) + 1):
            for i in range(j):
                dp[j] = dp[i] and s[i:j] in wordDict
                if dp[j]:
                    break
        return dp[-1]
```

---

# 100169.移除栅栏得到的正方形田地的最大面积

​		有一个大型的 `(m - 1) x (n - 1)` 矩形田地，其两个对角分别是 `(1, 1)` 和 `(m, n)` ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 `hFences` 和 `vFences` 给出。

​		水平栅栏为坐标 `(hFences[i], 1)` 到 `(hFences[i], n)`，垂直栅栏为坐标 `(1, vFences[i])` 到 `(m, vFences[i])` 。

​		返回通过 **移除** 一些栅栏（**可能不移除**）所能形成的最大面积的 **正方形** 田地的面积，或者如果无法形成正方形田地则返回 `-1`。

​		由于答案可能很大，所以请返回结果对 `109 + 7` **取余** 后的值。

​		**注意：**田地外围两个水平栅栏（坐标 `(1, 1)` 到 `(1, n)` 和坐标 `(m, 1)` 到 `(m, n)` ）以及两个垂直栅栏（坐标 `(1, 1)` 到 `(m, 1)` 和坐标 `(1, n)` 到 `(m, n)` ）所包围。这些栅栏 **不能** 被移除。

## 1.思路

​		（差一点就想到了，感觉还是因为不太敢用暴力法解决问题）

​		枚举任意两条栅栏（包括最外面的边框）之间的距离，找到水平方向距离和垂直方向距离的交集，用其中最大的那个作为正方形田地的边，这样构成的正方形田地就是面积最大的。

## 2.代码

```python
"""
100169.移除栅栏得到的正方形田地的最大面积
暴力枚举。
"""


class Solution(object):
    def compute_distance(self, fences):
        fences.sort()
        distances = []
        for i in range(len(fences)):
            for j in range(i + 1, len(fences)):
                distances.append(fences[j] - fences[i])
        return list(set(distances))
    	"""return set(distances)"""

    def maximizeSquareArea(self, m, n, hFences, vFences):
        """
        :type m: int
        :type n: int
        :type hFences: List[int]
        :type vFences: List[int]
        :rtype: int
        """
        # 暴力枚举任意两个栅栏之间的距离
        hFences.extend([1, m])
        vFences.extend([1, n])
        h_distances = self.compute_distance(fences=hFences)
        v_distances = self.compute_distance(fences=vFences)
        # 查找交集，计算最大的正方形面积
        # 下面是基于列表+双指针的方法
        h_distances.sort()
        v_distances.sort()
        left, right = 0, 0
        max_edge = -1
        while left < len(h_distances) and right < len(v_distances):
            if h_distances[left] == v_distances[right]:
                # 这里注意一下，去找边而不是直接找最大面积，否则会有一点问题
                max_edge = max(max_edge, h_distances[left])
                left += 1
                right += 1
            elif h_distances[left] < v_distances[right]:
                left += 1
            else:
                right += 1
        return max_edge ** 2 % (10 ** 9 + 7) if max_edge != -1 else -1
    	# 下面是基于集合的方法
        """cover_distances = h_distances & v_distances
        if cover_distances:
            ans = max(cover_distances)
        else:
            ans = 0
        return ans ** 2 % (10 ** 9 + 7) if ans else -1"""


if __name__ == '__main__':
    sol = Solution()
    print(sol.maximizeSquareArea(m=6, n=7, hFences=[2], vFences=[4]))

```

---

# 100156.转换字符串的最小成本 I

​		给你两个下标从 **0** 开始的字符串 `source` 和 `target` ，它们的长度均为 `n` 并且由 **小写** 英文字母组成。

​		另给你两个下标从 **0** 开始的字符数组 `original` 和 `changed` ，以及一个整数数组 `cost` ，其中 `cost[i]` 代表将字符 `original[i]` 更改为字符 `changed[i]` 的成本。

​		你从字符串 `source` 开始。在一次操作中，**如果** 存在 **任意** 下标 `j` 满足 `cost[j] == z` 、`original[j] == x` 以及 `changed[j] == y` 。你就可以选择字符串中的一个字符 `x` 并以 `z` 的成本将其更改为字符 `y` 。

​		返回将字符串 `source` 转换为字符串 `target` 所需的 **最小** 成本。如果不可能完成转换，则返回 `-1` 。

​		**注意**，可能存在下标 `i` 、`j` 使得 `original[j] == original[i]` 且 `changed[j] == changed[i]` 。

## 1.多源最短路径：Floyd 算法

​		首先，根据最初的路径情况初始化可达矩阵。

​		然后，遍历节点，执行如下操作：

```python
for u in point_set:
    for v in point_set:
        for k in point_set:
            d[v][k] = min(d[v][u] + d[u][k], d[v][k])
```

用自然语言的方式来描述的话，就是节点`v`到节点`k`之间的距离是否会因为途径节点`u`而变短；如果会，则更新节点`v`到节点`k`之间的距离为新的最短距离。

​		当所有节点都当过一次中转之后，算法结束。

## 2. 思路

​		（差一点点就能做出来了……崩溃……）

​		这个题目有个很小的问题：`original`和`changed`中的字母可能存在重复。

​		如何理解重复，可能是`a`到`b`，`b`到`c`，所以`a`到`c`可以拓展出一条路径；也可以是`a`到`b`，`a`到`c`都有路径。还有一种情况，就是`a`到`b`之间可能存在权重不同的多条路径！

​		为了让总体的成本最小，如果两个节点之间存在多条路径，需要选择其中成本最小的那一条。所以在初始化可达矩阵的时候，需要加一个最小化的判断。

## 3. 代码

```python
"""
100156.转换字符串的最小成本 I
"""


class Solution(object):
    def minimumCost(self, source, target, original, changed, cost):
        """
        :type source: str
        :type target: str
        :type original: List[str]
        :type changed: List[str]
        :type cost: List[int]
        :rtype: int
        """
        MAX_INT = float("inf")
        # 求最短路径
        path = [[MAX_INT for _ in range(26)] for _ in range(26)]
        for i in range(26):
            path[i][i] = 0
        for i in range(len(original)):
            start = ord(original[i]) - ord("a")
            end = ord(changed[i]) - ord("a")
            # 这里有个细节问题：original 和 changed 里面的字母可以重复
            # “可以重复”的意思不仅仅是指路径可以扩展
            # 还有一种可能是 b -> c 这种直接的路线可以重复多次！
            path[start][end] = min(path[start][end], cost[i])
        # 多源最短路径：Floyd 算法
        for i in range(26):
            # 用第 i 个字母作为中转，考虑从第 j 个字母到第 k 个字母的情况
            for j in range(26):
                for k in range(26):
                    if (path[j][i] + path[i][k]) < path[j][k]:
                        path[j][k] = path[j][i] + path[i][k]
        # 开始考虑字符串的转换
        total_cost = 0
        for i in range(len(source)):
            if source[i] == target[i]:
                continue
            total_cost += path[ord(source[i]) - ord("a")][ord(target[i]) - ord("a")]
        return total_cost if total_cost < MAX_INT else -1
```

---

# 卡码网56.携带矿石资源

<!--到写笔记为止，没能在卡码网上通过。如果使用二维dp数组，内存会超限；如果用滚动数组，会提示潜在的指针或数组越界，但是代码本身应该是没有问题的，看评论区也没有用Python通过的，怀疑是后台的判题机制有问题。-->

题目描述

> ​		你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 
>
> ​		给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。

输入描述

> 输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。 
>
> 接下来的三行，每行包含 N 个正整数。具体如下： 
>
> 第二行包含 N 个整数，表示 N 种矿石的重量。 
>
> 第三行包含 N 个整数，表示 N 种矿石的价格。 
>
> 第四行包含 N 个整数，表示 N 种矿石的可用数量上限。

输出描述

> 输出一个整数，代表获取的最大价值。

## 1. 多重背包

​		和0-1背包和完全背包的区别在于，物品的数量不是1或者无限，而是某个固定的值`nums[i]`。

​		多重背包的解法在于将其转换为0-1背包，也就是把所有的物品展平，变成每个物品只有一个（但是物品的重量和价值可能相等）。这样就可以借用0-1背包的递推式解决多重背包问题了。

## 2. 二维dp数组代码

​		我没想到很好地解决多个物品的方法，所以干脆在求解之前先展平了，这样内存会有一点大。

```python
class Solution(object):
    def bag_problem(self, size, weights, values, nums):
        flat_weights, flat_values = [], []
        for i in range(len(nums)):
            flat_weights.extend([weights[i]] * nums[i])
            flat_values.extend([values[i]] * nums[i])
        # 初始化
        dp = [[0 for _ in range(size + 1)] for _ in range(sum(nums) + 1)]
        # 递推
        for i in range(1, sum(nums) + 1):
            for j in range(1, size + 1):
                if j >= flat_weights[i - 1]:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - flat_weights[i - 1]] + flat_values[i - 1])
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]
```

## 3. 滚动数组代码

​		用滚动数组会比二维数组要好想一点。直接在两层0-1背包遍历里面，加一层遍历物品数量即可。

```python
class Solution(object):
    def bag_problem(self, size, weights, values, nums):
        # 初始化
        dp = [0 for _ in range(size + 1)]
        for i in range(len(weights)):
            for j in range(size, weights[i] - 1, -1):
                for k in range(1, nums[i] + 1):
                    if j >= k * weights[i]:
                        dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i])
        return dp[-1]
```

---

# 213. 打家劫舍 II

​		你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

​		给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

## 1. 思路

​		其实就是两种情况，考虑从第一间房屋到倒数第二间房屋这个区间里能偷窃到的最高金额，或者从第二间房屋到最后一间房屋这个区间里能偷窃到的最高金额，两者之间取更大的那个。具体要不要偷第一间房屋和最后一间房屋由递推公式自己决定。

<!--被绕进去的地方在于，我认为是三种情况：必须偷第一间，必须偷最后一间，第一间和最后一间都不偷，所以根本没法用递推公式求出来。其实在第一种情况，如果不偷第一间想偷最后一间，在第二种情况里面已经包含了，反过来也是同理，具体偷不偷让递推公式自己决定就可以了。-->

## 2. 代码

```python
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 1:
            return nums[0]
        dp1 = [0 for _ in range(len(nums))]
        dp2 = [0 for _ in range(len(nums))]
        # 初始化
        dp1[1] = nums[0]
        dp2[1] = nums[1]
        # 递推
        for i in range(2, len(nums)):
            dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i - 1])
            dp2[i] = max(dp2[i - 1], dp2[i - 2] + nums[i])
        return max(dp1[-1], dp2[-1])
```

---

# 337. 打家劫舍 III

​		小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

​		除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

​		给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

![image-20231228103619495](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231228103619495.png)

## 1. 思路

​		首先这里必须用后序遍历！因为当遍历到某个节点时，计算当前节点偷或不偷能得到的最大金额，必须由孩子节点偷或者不偷计算，而且初始化也应该从叶子节点开始初始化。

​		其次，这里的 `dp` 不是一个长为 `n` 的数组，而是一个二维数组：第一个元素为不偷当前节点时能够得到的最大金额，第二个元素为偷当前节点时能够得到的最大金额。

​		对于每个节点，首先进行后序遍历，得到左子树的 `left`，右子树的 `right`。对于当前节点，如果偷，那么左右子树节点都不能偷，所以最终的结果是：`node.val + left[0] + right[0]`；如果不偷，那么左右子树节点可以偷，也可以不偷，由动态规划递推公式决定：`max(left[0], left[1]) + max(right[0], right[1])`。

​		对于初始化，如果当前节点是空节点，直接返回 `[0, 0]`；如果当前节点的左右节点均为空，直接返回 `[0, node.val]`。

## 2. 代码

```python
class Solution(object):
    def post_order(self, root):
        if not root:
            return [0, 0]
        if not root.left and not root.right:
            return [0, root.val]
        # 后序遍历
        left = self.post_order(root.left)
        right = self.post_order(root.right)
        # 偷当前节点
        val1 = root.val + left[0] + right[0]
        # 不偷当前节点
        val2 = max(left[0], left[1]) + max(right[0], right[1])
        return [val2, val1]

    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        result = self.post_order(root=root)
        return max(result[0], result[1])
```

---

# 121. 买卖股票的最佳时机

​		给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

​		你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

​		返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

## 1. 思路

​		和之前做过的贪心方法不同，这里股票的交易只能进行一次。

​		开始的时候，想用一维 `dp` 数组解决，但是没法记录股票是在哪一天买入的，所以根本写不出递推公式。

​		其实和 打家劫舍 III 一样，可以用二维数组来记录，第一个元素表示在第 `i` 天不持有股票时能获取的最大利润，第二个元素表示在第 `i` 天持有股票时能获得的最大利润。

​		那么可以写递推公式。当第 `i` 天不持有股票时，可能是之前一直未持有过股票 `dp[i - 1][0]`，也可能是之前持有股票，但是在第 `i` 天卖出 `dp[i - 1][1] + price[i]`，所以有 `dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + price[i])`。当第 `i` 天持有股票时，可能是之前一直持有股票 `dp[i - 1][1]`，也可能是在第 `i` 天买入了股票 `-price[i]`<!--这里稍微有个细节。关于在第 i 天买入股票能够获得的最大利润为什么是 -price[i] 而不是 dp[i - 1][0] - price[i]，因为股票买卖只有一次，所以如果在第 i 天买入了股票，说明之前从来没有进行过股票交易，持有的利润一定是 0。-->，所以有 `dp[i][1] = max(dp[i - 1][1], -price[i])`。

​		对于初始化，在第一天，如果不持有股票，那么能获得的利润为 0；如果持有股票，一定是在这一天买入的，能获得的利润为 `-price[0]`。

## 2. 代码

​		有个可以优化的细节：因为 `dp[i]` 只由 `dp[i - 1]` 决定，这里也可以用滚动数组代替多维数组。

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        # dp = [[0， -price[0]]]
        # for i in range(1, len(prices)):
        #     val1 = max(dp[i - 1][0], dp[i - 1][1] + price[i])
        #     val2 = max(dp[i - 1][1], -price[i])
        #     dp.append([val1, val2])
        # return dp[-1][0]
        dp = [0, -price[0]]
        for i in range(1, len(prices)):
            dp[0] = max(dp[0], dp[1] + price[i])
            dp[1] = max(dp[1], -price[i])
            dp = [val1, val2]
        return dp[0]
```

---

# 123. 买卖股票的最佳时机 III

​		给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

​		设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

​		**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 1. 思路

​		<!--关键问题是，如何记录现在已经完成了第几笔交易了。-->

​		`dp` 数组的每个元素有四个状态：（第一次持有股票，第一次不持有股票，第二次持有股票，第二次不持有股票）。

​		递推公式：

`dp[i][0] = max(dp[i - 1][0], -price[i])` - 第一次持有股票：之前就持有股票，在第 `i` 天买入股票

`dp[i][1] = max(dp[i - 1][1], dp[i][0] + price[i])` - 第一次不持有股票：之前就不持有股票，在第 `i` 天把第一次买入的股票卖出

`dp[i][2] = max(dp[i - 1][2], dp[i][1] - price[i])` - 第二次持有股票：之前就持有股票，在第 `i` 天在第一次不持有股票的基础上买入股票

`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] + price[i])` - 第二次不持有股票：之前就不持有股票，在第 `i` 天把第二次买入的股票卖出

​		初始化：`dp[0][0] = -price[0], dp[0][1] = 0, dp[0][2] = -price[0], dp[0][3] = 0`。对于第二次持有或不持有股票的情况，可以认为在第一天反复买入卖出。

## 2. 代码

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        # 四状态：(第一次不持有, 第一次持有, 第二次不持有, 第二次持有)
        dp = [[0, -prices[0], 0, -prices[0]]]
        for i in range(1, len(prices)):
            val1 = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            val2 = max(dp[i - 1][1], -prices[i])
            val3 = max(dp[i - 1][2], dp[i - 1][3] + prices[i])
            val4 = max(dp[i - 1][3], dp[i - 1][0] - prices[i])
            dp.append([val1, val2, val3, val4])
        return max(val for val in dp[-1])
```

---

# 309. 买卖股票的最佳时机含冷冻期

## 1. 思路

​		对于股票问题，添加各种条件的时候，一个直观的想法就是让动态规划的 `dp` 数组多几个状态。比如121.买卖股票的最佳时机就是`[持有股票, 不持有股票]`，123.买卖股票的最佳时机 III就是`[第一次持有股票, 第一次不持有股票, 第二次持有股票, 第二次不持有股票]`。

​		这个题目最好设置四个状态：`[持有股票, 保持股票卖出状态, 当天卖出股票, 处于冷冻期]`。其中，保持股票卖出状态时指，上一回合可能就是该状态，或者在两天前卖出了股票，刚好度过了冷冻期。

​		<!--其实开始的时候我设置了三个状态，把状态二和状态四合在一起，这样确实不好想，而且递推公式还有一个地方想错了，导致怎么推也推不出来。-->

​		根据上述分析，递推公式：

- 持有股票，可能是在昨天就持有股票，也可能昨天是保持股票卖出状态，也可能昨天处于冷冻期：

`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - price[i], dp[i - 1][3] - price[i])`。

- 保持股票卖出状态：

`dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])`。

- 当天卖出股票，前一天必须持有股票：

`dp[i][2] = dp[i - 1][0] + price[i]`。

- 处于冷冻期，说明前一天必须卖出了股票，因为冷冻期只能持续一天：

`dp[i][3] = dp[i - 1][2]`。

​		初始化：`dp[0] = [-price[0], 0, 0, 0]`。

## 2. 代码

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        # (持有股票，保持卖出股票状态，今天卖出股票，处于冷冻期状态)
        dp = [[0, 0, 0, 0] for _ in range(len(prices))]
        dp[0] = [-prices[0], 0, 0, 0]
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])
            dp[i][2] = dp[i - 1][0] + prices[i]
            dp[i][3] = dp[i - 1][2]
        return max(dp[-1])
```

## 3. 另一种思路

​		如果一定要用三种状态来做，三种状态分别是：`[持有股票, 今天卖出股票, 一直不持有股票]`。

​		递推公式：

- 持有股票，可能是昨天就持有股票，也可能昨天及之前已经度过了冷冻期：

`dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - price[i])`。

- 今天卖出股票，要求昨天或之前必须买入过股票：

`dp[i][1] = dp[i - 1][0] + price[i]`。

- 一直不持有股票，可能是处于冷冻期（昨天卖出过股票），也可能是之前一直不持有股票：

`dp[i][2] = max(dp[i - 1][2], dp[i - 1][1])`。<!--第一次做就是这里出错了：一直不持有股票，说明昨天可以是冷冻期。-->

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        # (持有股票，不持有股票且处于冷冻期，不持有股票且不处于冷冻期)
        dp = [[0, 0, 0] for _ in range(len(prices))]
        dp[0] = [-prices[0], 0, 0]
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i])
            dp[i][1] = dp[i - 1][0] + prices[i]
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1])
        print(dp)
        return max(dp[-1])
```

---

# 300. 最长递增子序列

​		给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

​		**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

## 1. 思路

​		和打家劫舍类问题不同，在这个题目里面，`dp[i]` 必须表示以 `i` 结尾的最长递增子序列长度，`nums[i]` 必须选中，否则没法找到子序列中上一个的位置了！

​		递归五步：

- `dp[i]` 表示以 `nums[i]` 为结尾的最长递增子序列长度。
- 递推公式：

$$
dp[i] =
\begin{cases}
	max(dp[i], dp[j] + 1) & nums[i] > nums[j], j \in [0, i - 1] \\
	dp[i] & others
\end{cases}
$$

- 初始化：`dp` 数组整个初始化为 1。
- 递推方向：从小到大。

## 2. 代码

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [1 for _ in range(len(nums))]
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

---

# 1035. 不相交的线

​		在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

​		现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

-  `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

​		请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

​		以这种方法绘制线条，并返回可以绘制的最大连线数。

## 1. 最初的思路

​		<!--单纯分析问题的话，其实原本也快考虑出来了，就是在递推公式上出了问题……-->

​		想要绘制一条从 `nums1[i]` 到 `nums2[j]` 之间的连线，需要两个条件：

1. `nums1[i] = nums2[j]`
2. 在 `nums1[i]` 和 `nums2[j]` 上没有其它连线了。换言之，最近可能的上一条连线只能是 `nums1[i - 1]` 和 `nums2[j - 1]` 之间的，否则一定会有重叠。

递推公式写出来发现和最长公共子序列是一样的。

## 2. 思路

​		从公共子序列的角度去思考。

​		能连线的节点之间构成的序列，相当于是 `nums1` 和 `nums2` 的公共子序列，而只要子序列中的相对位置不发生变化，连线之间一定不会重叠！

​		所以找最大连线数，相当于找 `nums1` 和 `nums2` 的最长公共子序列。
