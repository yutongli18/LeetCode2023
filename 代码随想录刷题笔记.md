# 216. 组合总和 III

## 1. 递归传参的逻辑

​		在回溯不重复问题中，递归传参需要传递当前位置的下一个位置，作为下一层递归 for 循环的起始位置。

​		注意这个传参，传递的应该是当前位置的下一个位置。也就是说，在 for 循环中：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
	k -= 1
	rest -= num
	curr_result.append(num)
	# 这里：需要向下一层传递的应该是当前的 num 的下一个元素
	# 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
	self.getCombines(k, rest, num + 1, curr_result[:])
	k += 1
	rest += num
	curr_result.pop(-1)
```

在 for 循环即将进入下一层递归时，当前的位置应该是 `num`，而不是  `start_index`。这里写错的话，会导致从 2 开始往后的元素都会被多次重复。

## 2. 终止条件

​		本题的终止条件适合用 `k` （剩余可选的元素数量）做判断，因为 `k` 在递归中只有两种情况：`> 0` 或 `== 0`。（因为 `k` 每次只减1，不会像 `rest` 那样突变。）

​		如果用 `rest`（剩余待拼凑的总和）做判断，需要同时对 `> 0`，`< 0` 和 `== 0` 三种情况做判断，会多写很多代码。

```python
# 这里：用 k 来做终止条件
# 用 rest 的话需要三重判断
if k == 0:
	if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
	return
```

## 3. 剪枝优化

​		本题可以做的剪枝有两种：当前元素集合中剩余可选元素的数量要大于等于题目要求的还需要加入组合的元素数量；当前剩余需要拼凑的总和要小于等于准备加入当前组合的元素值，也即：
$$
num <= rest
$$

$$
10 - num <= k
$$

还有一个默认的条件是：
$$
num <= 9
$$
所以在 `for` 循环上写剪枝条件：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):
```

## 4. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []

    def getCombines(self, k, rest, start_index, curr_result):
        # 这里：用 k 来做终止条件
        # 用 rest 的话需要三重判断
        if k == 0:
            if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
                self.result_list.append(curr_result)
            return
        for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
            k -= 1
            rest -= num
            curr_result.append(num)
            # 这里：需要向下一层传递的应该是当前的 num 的下一个元素
            # 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
            self.getCombines(k, rest, num + 1, curr_result[:])
            k += 1
            rest += num
            curr_result.pop(-1)

    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        self.getCombines(k, n, 1, [])
        return self.result_list
```

# 40. 组合总和 II

​		给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
​		candidates 中的每个数字在每个组合中只能使用一次。
​		注意：解集不能包含重复的组合。 

```python
示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

示例 2:
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

​		和组合总和 III 的区别：本题对组合中元素的个数没有限制，并且候选集合中的元素存在重复。

​		和组合总和的区别：本题候选集合中的元素存在重复。

## 1. 同层剪枝

​		因为候选集合中的元素存在重复，想要最终集合中的组合不重复，需要在同一树层上进行剪枝：

![image-20231028100627447](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231028100627447.png)

​		因为是在同一树层上剪枝，所以这个剪枝的过程一定发生在 `for` 循环中，并且不能影响到不同树层间重复元素的选取（例如 `[1, 1, 6]`）。

​		最简单的做法：

```python
for index in range(start_index, len(candidates)):
    ...
    if index > start_index and candidates[index] == candidates[index - 1]:
        continue
    ...
```

`candidates[index] == candidates[index - 1]` 是在把重复的数字构成的树枝剪掉；`index > start_index` 是为了确保这个剪枝过程发生在同一树层上，而不是树层之间。

​		注意：想要实现上述代码的效果，必须先对候选集合 `candidates` 进行排序。

## 2. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []

    def getCombine(self, candidates, start_index, rest):
        if rest == 0:
            self.result_list.append(self.curr_result[:])
            return

        for index in range(start_index, len(candidates)):
            # 因为排序了，所以后面的元素一定更大，不需要再遍历了
            if rest - candidates[index] < 0:
                break
            # 同层剪枝
            if index > start_index and candidates[index] == candidates[index - 1]:
                continue
            rest -= candidates[index]
            self.curr_result.append(candidates[index])
            self.getCombine(candidates, index + 1, rest)
            rest += candidates[index]
            self.curr_result.pop(-1)

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # 必须要先排序！
        candidates.sort()
        self.getCombine(candidates, start_index=0, rest=target)
        return self.result_list
```

# 131. 分割回文串

## 1. 判断是否为回文串

​		可以用双指针法判断一个字符串是否为回文串：

```python
def is_palindrome(self, s):
    """
    判断 s 是否为回文串
    :param s: string 待判断的字符串
    :return: bool 是否为回文串
    """
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

## 2. 如何把分割问题转化为回溯问题

​		对于子串分割问题，现在 `for` 循环遍历的应该是切割位置。对于长为 `length` 的字符串，一共有 `length + 1` 个切割位置（最后一个切割位置在子串的最后，是为了判断终止条件添加的）。

​		因为不能有重复的切割，所以已经切割过一次的位置就不能再进行切割了，每次应该从下一个切割位置开始切割。这也就导致了把当前子串一分为二之后，左边的那个子串是不需要递归切割的（因为它要么是一个单元素子串，要么包含已经被切割过的位置），只需要对右面的那个子串进行递归切割即可。

## 3. 如何判断终止条件

​		结合 2，终止条件应该是当前整个字符串都切割完成之后，所以在长为 `length` 的字符串的 `length` 索引处添加一个切割位置，这个切割位置会把子串切割为一个子串和一个空串。当递归中出现空串时，说明此时切割已经到了末尾，可以向结果集合中添加本次切割的结果了。

## 4. 剪枝

​		结合 2，本次切割之后，左面的那个子串不需要递归切割，因此它是否满足回文串，决定了本次切割是否还需要进行下去。如果它是回文串，那么递归切割右子串；否则，本次切割失败，直接返回。

​		综合上述 2，3，4，可以写出回溯的代码：

```javascript
def get_partition(self, s):
	// 终止条件：切割到字符串的最后
	if not s:
		self.result_list.append(self.curr_list[:])
		return
	// 让切割位置从 1 到 length，length 位置是为了终止条件添加上去的
	for i in range(1, len(s) + 1):
		s_left, s_right = s[:i], s[i:]
		// 左子串是不需要递归切割的，它是否是回文串决定了本次切割是否还需要进行下去
		if not self.is_palindrome(s_left):
			continue
		self.curr_list.append(s_left[:])
		// 递归切割右子串
		self.get_partition(s_right[:])
		// 回溯
		self.curr_list.pop(-1)
```

