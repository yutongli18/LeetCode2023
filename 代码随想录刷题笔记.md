# 216. 组合总和 III

## 1. 递归传参的逻辑

​		在回溯不重复问题中，递归传参需要传递当前位置的下一个位置，作为下一层递归 for 循环的起始位置。

​		注意这个传参，传递的应该是当前位置的下一个位置。也就是说，在 for 循环中：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
	k -= 1
	rest -= num
	curr_result.append(num)
	# 这里：需要向下一层传递的应该是当前的 num 的下一个元素
	# 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
	self.getCombines(k, rest, num + 1, curr_result[:])
	k += 1
	rest += num
	curr_result.pop(-1)
```

在 for 循环即将进入下一层递归时，当前的位置应该是 `num`，而不是  `start_index`。这里写错的话，会导致从 2 开始往后的元素都会被多次重复。

## 2. 终止条件

​		本题的终止条件适合用 `k` （剩余可选的元素数量）做判断，因为 `k` 在递归中只有两种情况：`> 0` 或 `== 0`。（因为 `k` 每次只减1，不会像 `rest` 那样突变。）

​		如果用 `rest`（剩余待拼凑的总和）做判断，需要同时对 `> 0`，`< 0` 和 `== 0` 三种情况做判断，会多写很多代码。

```python
# 这里：用 k 来做终止条件
# 用 rest 的话需要三重判断
if k == 0:
	if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
	return
```

## 3. 剪枝优化

​		本题可以做的剪枝有两种：当前元素集合中剩余可选元素的数量要大于等于题目要求的还需要加入组合的元素数量；当前剩余需要拼凑的总和要小于等于准备加入当前组合的元素值，也即：
$$
num <= rest
$$

$$
10 - num <= k
$$

还有一个默认的条件是：
$$
num <= 9
$$
所以在 `for` 循环上写剪枝条件：

```python
for num in range(start_index, min(10, rest + 1, 11 - k)):
```

## 4. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []

    def getCombines(self, k, rest, start_index, curr_result):
        # 这里：用 k 来做终止条件
        # 用 rest 的话需要三重判断
        if k == 0:
            if rest == 0:  # 达成条件了，直接返回就行，没有必要再遍历下面的节点了
                self.result_list.append(curr_result)
            return
        for num in range(start_index, min(10, rest + 1, 11 - k)):  # 这里同时有两重剪枝可以做
            k -= 1
            rest -= num
            curr_result.append(num)
            # 这里：需要向下一层传递的应该是当前的 num 的下一个元素
            # 第一次整体逻辑对了，但是写成了 start_index + 1，所以从 2 往后的全都有重复……
            self.getCombines(k, rest, num + 1, curr_result[:])
            k += 1
            rest += num
            curr_result.pop(-1)

    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        self.getCombines(k, n, 1, [])
        return self.result_list
```

# 40. 组合总和 II

​		给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
​		candidates 中的每个数字在每个组合中只能使用一次。
​		注意：解集不能包含重复的组合。 

```python
示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

示例 2:
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

​		和组合总和 III 的区别：本题对组合中元素的个数没有限制，并且候选集合中的元素存在重复。

​		和组合总和的区别：本题候选集合中的元素存在重复。

## 1. 同层剪枝

​		因为候选集合中的元素存在重复，想要最终集合中的组合不重复，需要在同一树层上进行剪枝：

![image-20231028100627447](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231028100627447.png)

​		因为是在同一树层上剪枝，所以这个剪枝的过程一定发生在 `for` 循环中，并且不能影响到不同树层间重复元素的选取（例如 `[1, 1, 6]`）。

​		最简单的做法：

```python
for index in range(start_index, len(candidates)):
    ...
    if index > start_index and candidates[index] == candidates[index - 1]:
        continue
    ...
```

`candidates[index] == candidates[index - 1]` 是在把重复的数字构成的树枝剪掉；`index > start_index` 是为了确保这个剪枝过程发生在同一树层上，而不是树层之间。

​		注意：想要实现上述代码的效果，必须先对候选集合 `candidates` 进行排序。

## 2. 整体代码

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []

    def getCombine(self, candidates, start_index, rest):
        if rest == 0:
            self.result_list.append(self.curr_result[:])
            return

        for index in range(start_index, len(candidates)):
            # 因为排序了，所以后面的元素一定更大，不需要再遍历了
            if rest - candidates[index] < 0:
                break
            # 同层剪枝
            if index > start_index and candidates[index] == candidates[index - 1]:
                continue
            rest -= candidates[index]
            self.curr_result.append(candidates[index])
            self.getCombine(candidates, index + 1, rest)
            rest += candidates[index]
            self.curr_result.pop(-1)

    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # 必须要先排序！
        candidates.sort()
        self.getCombine(candidates, start_index=0, rest=target)
        return self.result_list
```

# 131. 分割回文串

## 1. 判断是否为回文串

​		可以用双指针法判断一个字符串是否为回文串：

```python
def is_palindrome(self, s):
    """
    判断 s 是否为回文串
    :param s: string 待判断的字符串
    :return: bool 是否为回文串
    """
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

## 2. 如何把分割问题转化为回溯问题

​		对于子串分割问题，现在 `for` 循环遍历的应该是切割位置。对于长为 `length` 的字符串，一共有 `length + 1` 个切割位置（最后一个切割位置在子串的最后，是为了判断终止条件添加的）。

​		因为不能有重复的切割，所以已经切割过一次的位置就不能再进行切割了，每次应该从下一个切割位置开始切割。这也就导致了把当前子串一分为二之后，左边的那个子串是不需要递归切割的（因为它要么是一个单元素子串，要么包含已经被切割过的位置），只需要对右面的那个子串进行递归切割即可。

## 3. 如何判断终止条件

​		结合 2，终止条件应该是当前整个字符串都切割完成之后，所以在长为 `length` 的字符串的 `length` 索引处添加一个切割位置，这个切割位置会把子串切割为一个子串和一个空串。当递归中出现空串时，说明此时切割已经到了末尾，可以向结果集合中添加本次切割的结果了。

## 4. 剪枝

​		结合 2，本次切割之后，左面的那个子串不需要递归切割，因此它是否满足回文串，决定了本次切割是否还需要进行下去。如果它是回文串，那么递归切割右子串；否则，本次切割失败，直接返回。

​		综合上述 2，3，4，可以写出回溯的代码：

```javascript
def get_partition(self, s):
	// 终止条件：切割到字符串的最后
	if not s:
		self.result_list.append(self.curr_list[:])
		return
	// 让切割位置从 1 到 length，length 位置是为了终止条件添加上去的
	for i in range(1, len(s) + 1):
		s_left, s_right = s[:i], s[i:]
		// 左子串是不需要递归切割的，它是否是回文串决定了本次切割是否还需要进行下去
		if not self.is_palindrome(s_left):
			continue
		self.curr_list.append(s_left[:])
		// 递归切割右子串
		self.get_partition(s_right[:])
		// 回溯
		self.curr_list.pop(-1)
```

# 491. 递增子序列

​		给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

​		数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

## 1. 层去重上的陷阱

​		这个题目看起来和之前做的层去重（组合总和 II）很像，但是不能采用之前的方法。因为原始数组不能被排序，否则会破坏题目的要求。也就是说，会出现这样的输入：`nums = [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]`，还有一些重复的 `1` 和前面的 `1` 是分开的。

​		所以这个题目只能采用复杂一点的字典记录法：用一个字典记录该元素在该层上是否已经搜索过了。

```python
def find_subsequences(self, nums, start_index):
	if len(self.curr_result) >= 2:
		self.result_list.append(self.curr_result[:])
	# 这个 used_dict 不作为参数传递，也不能放在全局的 init 里面
	# 因为它只管层去重，而不是整棵树去重。
	used_dict = {}
	for index in range(start_index, min(len(self.curr_result) + len(nums) - 1, len(nums))):
		used_dict.setdefault(nums[index], False)
        # 层去重的部分在这里
		if used_dict[nums[index]]:
			continue
		used_dict[nums[index]] = True
        # 递增剪枝的部分在这里
		if self.curr_result and nums[index] < self.curr_result[-1]:
			continue
		self.curr_result.append(nums[index])
		self.find_subsequences(nums, index + 1)
		self.curr_result.pop(-1)
```

# 100116. 找到冠军 II

​		一场比赛中共有 `n` 支队伍，按从 `0` 到 `n - 1` 编号。每支队伍也是 **有向无环图（DAG）** 上的一个节点。

​		给你一个整数 `n` 和一个下标从 **0** 开始、长度为 `m` 的二维整数数组 `edges` 表示这个有向无环图，其中 `edges[i] = [ui, vi]` 表示图中存在一条从 `ui` 队到 `vi` 队的有向边。

​		从 `a` 队到 `b` 队的有向边意味着 `a` 队比 `b` 队 **强** ，也就是 `b` 队比 `a` 队 **弱** 。

​		在这场比赛中，如果不存在某支强于 `a` 队的队伍，则认为 `a` 队将会是 **冠军** 。

​		如果这场比赛存在 **唯一** 一个冠军，则返回将会成为冠军的队伍。否则，返回 `-1` *。*

**注意**

- **环** 是形如 `a1, a2, ..., an, an+1` 的一个序列，且满足：节点 `a1` 与节点 `an+1` 是同一个节点；节点 `a1, a2, ..., an` 互不相同；对于范围 `[1, n]` 中的每个 `i` ，均存在一条从节点 `ai` 到节点 `ai+1` 的有向边。
- **有向无环图** 是不存在任何环的有向图。

## 1. 最初的思路

​		和《找到冠军 I》不同，`a` 队比 `b` 队强，`b` 队比 `c` 队强，因此 `a` 队比 `c` 队强的这种递推关系，不一定有边，而是有可能通过边之间的传递来表达，所以不能沿用上一题的做法，直接去找有没有一个节点有 `n - 1` 条出边。

​		然后又想到能不能找到每个节点所有路径上的所有节点，衍生出一个回溯+递归的思路，但是这种做法还有一个需要去重的问题。例如 `edges =[[0,1],[1,2],[0,2]], n=3`，在找 `0` 队的路径时，`2` 会被统计两次。在递归和回溯上很难去重，因此这种方法也不能通过。

## 2. 解决方案

​		其实很简单，冠军 = 不能被打败的队伍。统计 `edge[i][1]` 中出现过的所有队伍编号，这些队伍都是被打败过的，不可能是冠军。如果最后仅有一支队伍不在编号集合中，那么这支队伍就是冠军；否则冠军一定不止一个。

​		可以用几行代码快速解决问题：

```python
is_defeated = [False] * n
for edge in edges:
	if not is_defeated[edge[1]]:
		is_defeated[edge[1]] = True
	if sum(is_defeated) == n - 1:
		for group_id in range(n):
			if not is_defeated[group_id]:
	else:
		return -1
```

# 46. 全排列

​		给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

## 1. 和组合问题的区别

​		排列问题和组合问题的区别在于，排列问题是有序的。也就是说，`start_index` 没有意义了，每次都要从头开始遍历。

![image-20231106095622195](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20231106095622195.png)

上图中蓝色框的位置，选了 3 之后，还可以调头回来再选 2。

## 2. 最初的想法

​		在递归函数上传递一个 `nums` 的子集，选中一个元素就把这个元素从集合中拿出去，再向下递归；回溯的时候，再把这个元素加回来。

​		可以实现，也能够通过，但是在把元素加回来的时候，需要添加到这个元素原来的位置（否则会重复选取），用到 `python` 的 `insert` 方法，很麻烦。

## 3. 解决方案

​		维护一个 `used` 字典，记录哪些数字已经被选取过了，再 `for` 遍历的时候，把这些数字跳过，不再选取。

​		注意：和 <u>491.递归子序列</u> 的区别。这次的 `used` 字典必须是全局的，因为这次不是在每层上去重，而是在全局路径上去重。也即，对于每条递归路径，不能选取重复的元素。

```python
class Solution(object):
    def __init__(self):
        self.result_list = []
        self.curr_result = []
        # used_dict 必须是一个全局的，因为去重在每条路径上，而不是每层
        self.used_dict = {}

    def get_permute(self, nums):
        if len(self.curr_result) == len(nums):
            self.result_list.append(self.curr_result[:])
            return
        for index in range(0, len(nums)):
            if not self.used_dict[nums[index]]:
                self.curr_result.append(nums[index])
                self.used_dict[nums[index]] = True
                self.get_permute(nums[:])
                self.used_dict[nums[index]] = False
                self.curr_result.pop(-1)

    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        self.used_dict = {num: False for num in nums}
        self.get_permute(nums)
        return self.result_list
```

